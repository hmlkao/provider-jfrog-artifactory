//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnonymousUser) DeepCopyInto(out *AnonymousUser) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnonymousUser.
func (in *AnonymousUser) DeepCopy() *AnonymousUser {
	if in == nil {
		return nil
	}
	out := new(AnonymousUser)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AnonymousUser) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnonymousUserInitParameters) DeepCopyInto(out *AnonymousUserInitParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnonymousUserInitParameters.
func (in *AnonymousUserInitParameters) DeepCopy() *AnonymousUserInitParameters {
	if in == nil {
		return nil
	}
	out := new(AnonymousUserInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnonymousUserList) DeepCopyInto(out *AnonymousUserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AnonymousUser, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnonymousUserList.
func (in *AnonymousUserList) DeepCopy() *AnonymousUserList {
	if in == nil {
		return nil
	}
	out := new(AnonymousUserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AnonymousUserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnonymousUserObservation) DeepCopyInto(out *AnonymousUserObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnonymousUserObservation.
func (in *AnonymousUserObservation) DeepCopy() *AnonymousUserObservation {
	if in == nil {
		return nil
	}
	out := new(AnonymousUserObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnonymousUserParameters) DeepCopyInto(out *AnonymousUserParameters) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnonymousUserParameters.
func (in *AnonymousUserParameters) DeepCopy() *AnonymousUserParameters {
	if in == nil {
		return nil
	}
	out := new(AnonymousUserParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnonymousUserSpec) DeepCopyInto(out *AnonymousUserSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	out.ForProvider = in.ForProvider
	out.InitProvider = in.InitProvider
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnonymousUserSpec.
func (in *AnonymousUserSpec) DeepCopy() *AnonymousUserSpec {
	if in == nil {
		return nil
	}
	out := new(AnonymousUserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnonymousUserStatus) DeepCopyInto(out *AnonymousUserStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnonymousUserStatus.
func (in *AnonymousUserStatus) DeepCopy() *AnonymousUserStatus {
	if in == nil {
		return nil
	}
	out := new(AnonymousUserStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Backup) DeepCopyInto(out *Backup) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Backup.
func (in *Backup) DeepCopy() *Backup {
	if in == nil {
		return nil
	}
	out := new(Backup)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Backup) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupInitParameters) DeepCopyInto(out *BackupInitParameters) {
	*out = *in
	if in.CreateArchive != nil {
		in, out := &in.CreateArchive, &out.CreateArchive
		*out = new(bool)
		**out = **in
	}
	if in.CronExp != nil {
		in, out := &in.CronExp, &out.CronExp
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ExcludeNewRepositories != nil {
		in, out := &in.ExcludeNewRepositories, &out.ExcludeNewRepositories
		*out = new(bool)
		**out = **in
	}
	if in.ExcludedRepositories != nil {
		in, out := &in.ExcludedRepositories, &out.ExcludedRepositories
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ExportMissionControl != nil {
		in, out := &in.ExportMissionControl, &out.ExportMissionControl
		*out = new(bool)
		**out = **in
	}
	if in.RetentionPeriodHours != nil {
		in, out := &in.RetentionPeriodHours, &out.RetentionPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.SendMailOnError != nil {
		in, out := &in.SendMailOnError, &out.SendMailOnError
		*out = new(bool)
		**out = **in
	}
	if in.VerifyDiskSpace != nil {
		in, out := &in.VerifyDiskSpace, &out.VerifyDiskSpace
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupInitParameters.
func (in *BackupInitParameters) DeepCopy() *BackupInitParameters {
	if in == nil {
		return nil
	}
	out := new(BackupInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupList) DeepCopyInto(out *BackupList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Backup, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupList.
func (in *BackupList) DeepCopy() *BackupList {
	if in == nil {
		return nil
	}
	out := new(BackupList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *BackupList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupObservation) DeepCopyInto(out *BackupObservation) {
	*out = *in
	if in.CreateArchive != nil {
		in, out := &in.CreateArchive, &out.CreateArchive
		*out = new(bool)
		**out = **in
	}
	if in.CronExp != nil {
		in, out := &in.CronExp, &out.CronExp
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ExcludeNewRepositories != nil {
		in, out := &in.ExcludeNewRepositories, &out.ExcludeNewRepositories
		*out = new(bool)
		**out = **in
	}
	if in.ExcludedRepositories != nil {
		in, out := &in.ExcludedRepositories, &out.ExcludedRepositories
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ExportMissionControl != nil {
		in, out := &in.ExportMissionControl, &out.ExportMissionControl
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.RetentionPeriodHours != nil {
		in, out := &in.RetentionPeriodHours, &out.RetentionPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.SendMailOnError != nil {
		in, out := &in.SendMailOnError, &out.SendMailOnError
		*out = new(bool)
		**out = **in
	}
	if in.VerifyDiskSpace != nil {
		in, out := &in.VerifyDiskSpace, &out.VerifyDiskSpace
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupObservation.
func (in *BackupObservation) DeepCopy() *BackupObservation {
	if in == nil {
		return nil
	}
	out := new(BackupObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupParameters) DeepCopyInto(out *BackupParameters) {
	*out = *in
	if in.CreateArchive != nil {
		in, out := &in.CreateArchive, &out.CreateArchive
		*out = new(bool)
		**out = **in
	}
	if in.CronExp != nil {
		in, out := &in.CronExp, &out.CronExp
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.ExcludeNewRepositories != nil {
		in, out := &in.ExcludeNewRepositories, &out.ExcludeNewRepositories
		*out = new(bool)
		**out = **in
	}
	if in.ExcludedRepositories != nil {
		in, out := &in.ExcludedRepositories, &out.ExcludedRepositories
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ExportMissionControl != nil {
		in, out := &in.ExportMissionControl, &out.ExportMissionControl
		*out = new(bool)
		**out = **in
	}
	if in.RetentionPeriodHours != nil {
		in, out := &in.RetentionPeriodHours, &out.RetentionPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.SendMailOnError != nil {
		in, out := &in.SendMailOnError, &out.SendMailOnError
		*out = new(bool)
		**out = **in
	}
	if in.VerifyDiskSpace != nil {
		in, out := &in.VerifyDiskSpace, &out.VerifyDiskSpace
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupParameters.
func (in *BackupParameters) DeepCopy() *BackupParameters {
	if in == nil {
		return nil
	}
	out := new(BackupParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupSpec) DeepCopyInto(out *BackupSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupSpec.
func (in *BackupSpec) DeepCopy() *BackupSpec {
	if in == nil {
		return nil
	}
	out := new(BackupSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BackupStatus) DeepCopyInto(out *BackupStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BackupStatus.
func (in *BackupStatus) DeepCopy() *BackupStatus {
	if in == nil {
		return nil
	}
	out := new(BackupStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContentSynchronisationInitParameters) DeepCopyInto(out *ContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContentSynchronisationInitParameters.
func (in *ContentSynchronisationInitParameters) DeepCopy() *ContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(ContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContentSynchronisationObservation) DeepCopyInto(out *ContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContentSynchronisationObservation.
func (in *ContentSynchronisationObservation) DeepCopy() *ContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(ContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContentSynchronisationParameters) DeepCopyInto(out *ContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContentSynchronisationParameters.
func (in *ContentSynchronisationParameters) DeepCopy() *ContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(ContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ItemProperties) DeepCopyInto(out *ItemProperties) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ItemProperties.
func (in *ItemProperties) DeepCopy() *ItemProperties {
	if in == nil {
		return nil
	}
	out := new(ItemProperties)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ItemProperties) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ItemPropertiesInitParameters) DeepCopyInto(out *ItemPropertiesInitParameters) {
	*out = *in
	if in.IsRecursive != nil {
		in, out := &in.IsRecursive, &out.IsRecursive
		*out = new(bool)
		**out = **in
	}
	if in.ItemPath != nil {
		in, out := &in.ItemPath, &out.ItemPath
		*out = new(string)
		**out = **in
	}
	if in.Properties != nil {
		in, out := &in.Properties, &out.Properties
		*out = make(map[string][]*string, len(*in))
		for key, val := range *in {
			var outVal []*string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = make([]*string, len(*in))
				for i := range *in {
					if (*in)[i] != nil {
						in, out := &(*in)[i], &(*out)[i]
						*out = new(string)
						**out = **in
					}
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.RepoKey != nil {
		in, out := &in.RepoKey, &out.RepoKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ItemPropertiesInitParameters.
func (in *ItemPropertiesInitParameters) DeepCopy() *ItemPropertiesInitParameters {
	if in == nil {
		return nil
	}
	out := new(ItemPropertiesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ItemPropertiesList) DeepCopyInto(out *ItemPropertiesList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ItemProperties, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ItemPropertiesList.
func (in *ItemPropertiesList) DeepCopy() *ItemPropertiesList {
	if in == nil {
		return nil
	}
	out := new(ItemPropertiesList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ItemPropertiesList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ItemPropertiesObservation) DeepCopyInto(out *ItemPropertiesObservation) {
	*out = *in
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IsRecursive != nil {
		in, out := &in.IsRecursive, &out.IsRecursive
		*out = new(bool)
		**out = **in
	}
	if in.ItemPath != nil {
		in, out := &in.ItemPath, &out.ItemPath
		*out = new(string)
		**out = **in
	}
	if in.Properties != nil {
		in, out := &in.Properties, &out.Properties
		*out = make(map[string][]*string, len(*in))
		for key, val := range *in {
			var outVal []*string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = make([]*string, len(*in))
				for i := range *in {
					if (*in)[i] != nil {
						in, out := &(*in)[i], &(*out)[i]
						*out = new(string)
						**out = **in
					}
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.RepoKey != nil {
		in, out := &in.RepoKey, &out.RepoKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ItemPropertiesObservation.
func (in *ItemPropertiesObservation) DeepCopy() *ItemPropertiesObservation {
	if in == nil {
		return nil
	}
	out := new(ItemPropertiesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ItemPropertiesParameters) DeepCopyInto(out *ItemPropertiesParameters) {
	*out = *in
	if in.IsRecursive != nil {
		in, out := &in.IsRecursive, &out.IsRecursive
		*out = new(bool)
		**out = **in
	}
	if in.ItemPath != nil {
		in, out := &in.ItemPath, &out.ItemPath
		*out = new(string)
		**out = **in
	}
	if in.Properties != nil {
		in, out := &in.Properties, &out.Properties
		*out = make(map[string][]*string, len(*in))
		for key, val := range *in {
			var outVal []*string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = make([]*string, len(*in))
				for i := range *in {
					if (*in)[i] != nil {
						in, out := &(*in)[i], &(*out)[i]
						*out = new(string)
						**out = **in
					}
				}
			}
			(*out)[key] = outVal
		}
	}
	if in.RepoKey != nil {
		in, out := &in.RepoKey, &out.RepoKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ItemPropertiesParameters.
func (in *ItemPropertiesParameters) DeepCopy() *ItemPropertiesParameters {
	if in == nil {
		return nil
	}
	out := new(ItemPropertiesParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ItemPropertiesSpec) DeepCopyInto(out *ItemPropertiesSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ItemPropertiesSpec.
func (in *ItemPropertiesSpec) DeepCopy() *ItemPropertiesSpec {
	if in == nil {
		return nil
	}
	out := new(ItemPropertiesSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ItemPropertiesStatus) DeepCopyInto(out *ItemPropertiesStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ItemPropertiesStatus.
func (in *ItemPropertiesStatus) DeepCopy() *ItemPropertiesStatus {
	if in == nil {
		return nil
	}
	out := new(ItemPropertiesStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Keypair) DeepCopyInto(out *Keypair) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Keypair.
func (in *Keypair) DeepCopy() *Keypair {
	if in == nil {
		return nil
	}
	out := new(Keypair)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Keypair) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeypairInitParameters) DeepCopyInto(out *KeypairInitParameters) {
	*out = *in
	if in.Alias != nil {
		in, out := &in.Alias, &out.Alias
		*out = new(string)
		**out = **in
	}
	if in.PairType != nil {
		in, out := &in.PairType, &out.PairType
		*out = new(string)
		**out = **in
	}
	if in.PassphraseSecretRef != nil {
		in, out := &in.PassphraseSecretRef, &out.PassphraseSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	out.PrivateKeySecretRef = in.PrivateKeySecretRef
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeypairInitParameters.
func (in *KeypairInitParameters) DeepCopy() *KeypairInitParameters {
	if in == nil {
		return nil
	}
	out := new(KeypairInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeypairList) DeepCopyInto(out *KeypairList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Keypair, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeypairList.
func (in *KeypairList) DeepCopy() *KeypairList {
	if in == nil {
		return nil
	}
	out := new(KeypairList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *KeypairList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeypairObservation) DeepCopyInto(out *KeypairObservation) {
	*out = *in
	if in.Alias != nil {
		in, out := &in.Alias, &out.Alias
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.PairType != nil {
		in, out := &in.PairType, &out.PairType
		*out = new(string)
		**out = **in
	}
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeypairObservation.
func (in *KeypairObservation) DeepCopy() *KeypairObservation {
	if in == nil {
		return nil
	}
	out := new(KeypairObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeypairParameters) DeepCopyInto(out *KeypairParameters) {
	*out = *in
	if in.Alias != nil {
		in, out := &in.Alias, &out.Alias
		*out = new(string)
		**out = **in
	}
	if in.PairType != nil {
		in, out := &in.PairType, &out.PairType
		*out = new(string)
		**out = **in
	}
	if in.PassphraseSecretRef != nil {
		in, out := &in.PassphraseSecretRef, &out.PassphraseSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	out.PrivateKeySecretRef = in.PrivateKeySecretRef
	if in.PublicKey != nil {
		in, out := &in.PublicKey, &out.PublicKey
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeypairParameters.
func (in *KeypairParameters) DeepCopy() *KeypairParameters {
	if in == nil {
		return nil
	}
	out := new(KeypairParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeypairSpec) DeepCopyInto(out *KeypairSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeypairSpec.
func (in *KeypairSpec) DeepCopy() *KeypairSpec {
	if in == nil {
		return nil
	}
	out := new(KeypairSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *KeypairStatus) DeepCopyInto(out *KeypairStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new KeypairStatus.
func (in *KeypairStatus) DeepCopy() *KeypairStatus {
	if in == nil {
		return nil
	}
	out := new(KeypairStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAlpineRepository) DeepCopyInto(out *LocalAlpineRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAlpineRepository.
func (in *LocalAlpineRepository) DeepCopy() *LocalAlpineRepository {
	if in == nil {
		return nil
	}
	out := new(LocalAlpineRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalAlpineRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAlpineRepositoryInitParameters) DeepCopyInto(out *LocalAlpineRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAlpineRepositoryInitParameters.
func (in *LocalAlpineRepositoryInitParameters) DeepCopy() *LocalAlpineRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalAlpineRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAlpineRepositoryList) DeepCopyInto(out *LocalAlpineRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalAlpineRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAlpineRepositoryList.
func (in *LocalAlpineRepositoryList) DeepCopy() *LocalAlpineRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalAlpineRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalAlpineRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAlpineRepositoryObservation) DeepCopyInto(out *LocalAlpineRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAlpineRepositoryObservation.
func (in *LocalAlpineRepositoryObservation) DeepCopy() *LocalAlpineRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalAlpineRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAlpineRepositoryParameters) DeepCopyInto(out *LocalAlpineRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAlpineRepositoryParameters.
func (in *LocalAlpineRepositoryParameters) DeepCopy() *LocalAlpineRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalAlpineRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAlpineRepositorySpec) DeepCopyInto(out *LocalAlpineRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAlpineRepositorySpec.
func (in *LocalAlpineRepositorySpec) DeepCopy() *LocalAlpineRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalAlpineRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAlpineRepositoryStatus) DeepCopyInto(out *LocalAlpineRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAlpineRepositoryStatus.
func (in *LocalAlpineRepositoryStatus) DeepCopy() *LocalAlpineRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalAlpineRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAnsibleRepository) DeepCopyInto(out *LocalAnsibleRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAnsibleRepository.
func (in *LocalAnsibleRepository) DeepCopy() *LocalAnsibleRepository {
	if in == nil {
		return nil
	}
	out := new(LocalAnsibleRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalAnsibleRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAnsibleRepositoryInitParameters) DeepCopyInto(out *LocalAnsibleRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRefRef != nil {
		in, out := &in.PrimaryKeypairRefRef, &out.PrimaryKeypairRefRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.PrimaryKeypairRefSelector != nil {
		in, out := &in.PrimaryKeypairRefSelector, &out.PrimaryKeypairRefSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAnsibleRepositoryInitParameters.
func (in *LocalAnsibleRepositoryInitParameters) DeepCopy() *LocalAnsibleRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalAnsibleRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAnsibleRepositoryList) DeepCopyInto(out *LocalAnsibleRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalAnsibleRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAnsibleRepositoryList.
func (in *LocalAnsibleRepositoryList) DeepCopy() *LocalAnsibleRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalAnsibleRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalAnsibleRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAnsibleRepositoryObservation) DeepCopyInto(out *LocalAnsibleRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAnsibleRepositoryObservation.
func (in *LocalAnsibleRepositoryObservation) DeepCopy() *LocalAnsibleRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalAnsibleRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAnsibleRepositoryParameters) DeepCopyInto(out *LocalAnsibleRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRefRef != nil {
		in, out := &in.PrimaryKeypairRefRef, &out.PrimaryKeypairRefRef
		*out = new(v1.Reference)
		(*in).DeepCopyInto(*out)
	}
	if in.PrimaryKeypairRefSelector != nil {
		in, out := &in.PrimaryKeypairRefSelector, &out.PrimaryKeypairRefSelector
		*out = new(v1.Selector)
		(*in).DeepCopyInto(*out)
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAnsibleRepositoryParameters.
func (in *LocalAnsibleRepositoryParameters) DeepCopy() *LocalAnsibleRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalAnsibleRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAnsibleRepositorySpec) DeepCopyInto(out *LocalAnsibleRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAnsibleRepositorySpec.
func (in *LocalAnsibleRepositorySpec) DeepCopy() *LocalAnsibleRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalAnsibleRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalAnsibleRepositoryStatus) DeepCopyInto(out *LocalAnsibleRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalAnsibleRepositoryStatus.
func (in *LocalAnsibleRepositoryStatus) DeepCopy() *LocalAnsibleRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalAnsibleRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalBowerRepository) DeepCopyInto(out *LocalBowerRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalBowerRepository.
func (in *LocalBowerRepository) DeepCopy() *LocalBowerRepository {
	if in == nil {
		return nil
	}
	out := new(LocalBowerRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalBowerRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalBowerRepositoryInitParameters) DeepCopyInto(out *LocalBowerRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalBowerRepositoryInitParameters.
func (in *LocalBowerRepositoryInitParameters) DeepCopy() *LocalBowerRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalBowerRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalBowerRepositoryList) DeepCopyInto(out *LocalBowerRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalBowerRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalBowerRepositoryList.
func (in *LocalBowerRepositoryList) DeepCopy() *LocalBowerRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalBowerRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalBowerRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalBowerRepositoryObservation) DeepCopyInto(out *LocalBowerRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalBowerRepositoryObservation.
func (in *LocalBowerRepositoryObservation) DeepCopy() *LocalBowerRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalBowerRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalBowerRepositoryParameters) DeepCopyInto(out *LocalBowerRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalBowerRepositoryParameters.
func (in *LocalBowerRepositoryParameters) DeepCopy() *LocalBowerRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalBowerRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalBowerRepositorySpec) DeepCopyInto(out *LocalBowerRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalBowerRepositorySpec.
func (in *LocalBowerRepositorySpec) DeepCopy() *LocalBowerRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalBowerRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalBowerRepositoryStatus) DeepCopyInto(out *LocalBowerRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalBowerRepositoryStatus.
func (in *LocalBowerRepositoryStatus) DeepCopy() *LocalBowerRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalBowerRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCargoRepository) DeepCopyInto(out *LocalCargoRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCargoRepository.
func (in *LocalCargoRepository) DeepCopy() *LocalCargoRepository {
	if in == nil {
		return nil
	}
	out := new(LocalCargoRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalCargoRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCargoRepositoryInitParameters) DeepCopyInto(out *LocalCargoRepositoryInitParameters) {
	*out = *in
	if in.AnonymousAccess != nil {
		in, out := &in.AnonymousAccess, &out.AnonymousAccess
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableSparseIndex != nil {
		in, out := &in.EnableSparseIndex, &out.EnableSparseIndex
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCargoRepositoryInitParameters.
func (in *LocalCargoRepositoryInitParameters) DeepCopy() *LocalCargoRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalCargoRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCargoRepositoryList) DeepCopyInto(out *LocalCargoRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalCargoRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCargoRepositoryList.
func (in *LocalCargoRepositoryList) DeepCopy() *LocalCargoRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalCargoRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalCargoRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCargoRepositoryObservation) DeepCopyInto(out *LocalCargoRepositoryObservation) {
	*out = *in
	if in.AnonymousAccess != nil {
		in, out := &in.AnonymousAccess, &out.AnonymousAccess
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableSparseIndex != nil {
		in, out := &in.EnableSparseIndex, &out.EnableSparseIndex
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCargoRepositoryObservation.
func (in *LocalCargoRepositoryObservation) DeepCopy() *LocalCargoRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalCargoRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCargoRepositoryParameters) DeepCopyInto(out *LocalCargoRepositoryParameters) {
	*out = *in
	if in.AnonymousAccess != nil {
		in, out := &in.AnonymousAccess, &out.AnonymousAccess
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableSparseIndex != nil {
		in, out := &in.EnableSparseIndex, &out.EnableSparseIndex
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCargoRepositoryParameters.
func (in *LocalCargoRepositoryParameters) DeepCopy() *LocalCargoRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalCargoRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCargoRepositorySpec) DeepCopyInto(out *LocalCargoRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCargoRepositorySpec.
func (in *LocalCargoRepositorySpec) DeepCopy() *LocalCargoRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalCargoRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCargoRepositoryStatus) DeepCopyInto(out *LocalCargoRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCargoRepositoryStatus.
func (in *LocalCargoRepositoryStatus) DeepCopy() *LocalCargoRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalCargoRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalChefRepository) DeepCopyInto(out *LocalChefRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalChefRepository.
func (in *LocalChefRepository) DeepCopy() *LocalChefRepository {
	if in == nil {
		return nil
	}
	out := new(LocalChefRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalChefRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalChefRepositoryInitParameters) DeepCopyInto(out *LocalChefRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalChefRepositoryInitParameters.
func (in *LocalChefRepositoryInitParameters) DeepCopy() *LocalChefRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalChefRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalChefRepositoryList) DeepCopyInto(out *LocalChefRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalChefRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalChefRepositoryList.
func (in *LocalChefRepositoryList) DeepCopy() *LocalChefRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalChefRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalChefRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalChefRepositoryObservation) DeepCopyInto(out *LocalChefRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalChefRepositoryObservation.
func (in *LocalChefRepositoryObservation) DeepCopy() *LocalChefRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalChefRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalChefRepositoryParameters) DeepCopyInto(out *LocalChefRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalChefRepositoryParameters.
func (in *LocalChefRepositoryParameters) DeepCopy() *LocalChefRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalChefRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalChefRepositorySpec) DeepCopyInto(out *LocalChefRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalChefRepositorySpec.
func (in *LocalChefRepositorySpec) DeepCopy() *LocalChefRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalChefRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalChefRepositoryStatus) DeepCopyInto(out *LocalChefRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalChefRepositoryStatus.
func (in *LocalChefRepositoryStatus) DeepCopy() *LocalChefRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalChefRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCocoapodsRepository) DeepCopyInto(out *LocalCocoapodsRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCocoapodsRepository.
func (in *LocalCocoapodsRepository) DeepCopy() *LocalCocoapodsRepository {
	if in == nil {
		return nil
	}
	out := new(LocalCocoapodsRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalCocoapodsRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCocoapodsRepositoryInitParameters) DeepCopyInto(out *LocalCocoapodsRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCocoapodsRepositoryInitParameters.
func (in *LocalCocoapodsRepositoryInitParameters) DeepCopy() *LocalCocoapodsRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalCocoapodsRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCocoapodsRepositoryList) DeepCopyInto(out *LocalCocoapodsRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalCocoapodsRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCocoapodsRepositoryList.
func (in *LocalCocoapodsRepositoryList) DeepCopy() *LocalCocoapodsRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalCocoapodsRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalCocoapodsRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCocoapodsRepositoryObservation) DeepCopyInto(out *LocalCocoapodsRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCocoapodsRepositoryObservation.
func (in *LocalCocoapodsRepositoryObservation) DeepCopy() *LocalCocoapodsRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalCocoapodsRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCocoapodsRepositoryParameters) DeepCopyInto(out *LocalCocoapodsRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCocoapodsRepositoryParameters.
func (in *LocalCocoapodsRepositoryParameters) DeepCopy() *LocalCocoapodsRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalCocoapodsRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCocoapodsRepositorySpec) DeepCopyInto(out *LocalCocoapodsRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCocoapodsRepositorySpec.
func (in *LocalCocoapodsRepositorySpec) DeepCopy() *LocalCocoapodsRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalCocoapodsRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCocoapodsRepositoryStatus) DeepCopyInto(out *LocalCocoapodsRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCocoapodsRepositoryStatus.
func (in *LocalCocoapodsRepositoryStatus) DeepCopy() *LocalCocoapodsRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalCocoapodsRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalComposerRepository) DeepCopyInto(out *LocalComposerRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalComposerRepository.
func (in *LocalComposerRepository) DeepCopy() *LocalComposerRepository {
	if in == nil {
		return nil
	}
	out := new(LocalComposerRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalComposerRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalComposerRepositoryInitParameters) DeepCopyInto(out *LocalComposerRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalComposerRepositoryInitParameters.
func (in *LocalComposerRepositoryInitParameters) DeepCopy() *LocalComposerRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalComposerRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalComposerRepositoryList) DeepCopyInto(out *LocalComposerRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalComposerRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalComposerRepositoryList.
func (in *LocalComposerRepositoryList) DeepCopy() *LocalComposerRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalComposerRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalComposerRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalComposerRepositoryObservation) DeepCopyInto(out *LocalComposerRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalComposerRepositoryObservation.
func (in *LocalComposerRepositoryObservation) DeepCopy() *LocalComposerRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalComposerRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalComposerRepositoryParameters) DeepCopyInto(out *LocalComposerRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalComposerRepositoryParameters.
func (in *LocalComposerRepositoryParameters) DeepCopy() *LocalComposerRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalComposerRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalComposerRepositorySpec) DeepCopyInto(out *LocalComposerRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalComposerRepositorySpec.
func (in *LocalComposerRepositorySpec) DeepCopy() *LocalComposerRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalComposerRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalComposerRepositoryStatus) DeepCopyInto(out *LocalComposerRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalComposerRepositoryStatus.
func (in *LocalComposerRepositoryStatus) DeepCopy() *LocalComposerRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalComposerRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalConanRepository) DeepCopyInto(out *LocalConanRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalConanRepository.
func (in *LocalConanRepository) DeepCopy() *LocalConanRepository {
	if in == nil {
		return nil
	}
	out := new(LocalConanRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalConanRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalConanRepositoryInitParameters) DeepCopyInto(out *LocalConanRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ForceConanAuthentication != nil {
		in, out := &in.ForceConanAuthentication, &out.ForceConanAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalConanRepositoryInitParameters.
func (in *LocalConanRepositoryInitParameters) DeepCopy() *LocalConanRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalConanRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalConanRepositoryList) DeepCopyInto(out *LocalConanRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalConanRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalConanRepositoryList.
func (in *LocalConanRepositoryList) DeepCopy() *LocalConanRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalConanRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalConanRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalConanRepositoryObservation) DeepCopyInto(out *LocalConanRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ForceConanAuthentication != nil {
		in, out := &in.ForceConanAuthentication, &out.ForceConanAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalConanRepositoryObservation.
func (in *LocalConanRepositoryObservation) DeepCopy() *LocalConanRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalConanRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalConanRepositoryParameters) DeepCopyInto(out *LocalConanRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ForceConanAuthentication != nil {
		in, out := &in.ForceConanAuthentication, &out.ForceConanAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalConanRepositoryParameters.
func (in *LocalConanRepositoryParameters) DeepCopy() *LocalConanRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalConanRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalConanRepositorySpec) DeepCopyInto(out *LocalConanRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalConanRepositorySpec.
func (in *LocalConanRepositorySpec) DeepCopy() *LocalConanRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalConanRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalConanRepositoryStatus) DeepCopyInto(out *LocalConanRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalConanRepositoryStatus.
func (in *LocalConanRepositoryStatus) DeepCopy() *LocalConanRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalConanRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCondaRepository) DeepCopyInto(out *LocalCondaRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCondaRepository.
func (in *LocalCondaRepository) DeepCopy() *LocalCondaRepository {
	if in == nil {
		return nil
	}
	out := new(LocalCondaRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalCondaRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCondaRepositoryInitParameters) DeepCopyInto(out *LocalCondaRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCondaRepositoryInitParameters.
func (in *LocalCondaRepositoryInitParameters) DeepCopy() *LocalCondaRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalCondaRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCondaRepositoryList) DeepCopyInto(out *LocalCondaRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalCondaRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCondaRepositoryList.
func (in *LocalCondaRepositoryList) DeepCopy() *LocalCondaRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalCondaRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalCondaRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCondaRepositoryObservation) DeepCopyInto(out *LocalCondaRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCondaRepositoryObservation.
func (in *LocalCondaRepositoryObservation) DeepCopy() *LocalCondaRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalCondaRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCondaRepositoryParameters) DeepCopyInto(out *LocalCondaRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCondaRepositoryParameters.
func (in *LocalCondaRepositoryParameters) DeepCopy() *LocalCondaRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalCondaRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCondaRepositorySpec) DeepCopyInto(out *LocalCondaRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCondaRepositorySpec.
func (in *LocalCondaRepositorySpec) DeepCopy() *LocalCondaRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalCondaRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCondaRepositoryStatus) DeepCopyInto(out *LocalCondaRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCondaRepositoryStatus.
func (in *LocalCondaRepositoryStatus) DeepCopy() *LocalCondaRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalCondaRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCranRepository) DeepCopyInto(out *LocalCranRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCranRepository.
func (in *LocalCranRepository) DeepCopy() *LocalCranRepository {
	if in == nil {
		return nil
	}
	out := new(LocalCranRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalCranRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCranRepositoryInitParameters) DeepCopyInto(out *LocalCranRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCranRepositoryInitParameters.
func (in *LocalCranRepositoryInitParameters) DeepCopy() *LocalCranRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalCranRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCranRepositoryList) DeepCopyInto(out *LocalCranRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalCranRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCranRepositoryList.
func (in *LocalCranRepositoryList) DeepCopy() *LocalCranRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalCranRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalCranRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCranRepositoryObservation) DeepCopyInto(out *LocalCranRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCranRepositoryObservation.
func (in *LocalCranRepositoryObservation) DeepCopy() *LocalCranRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalCranRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCranRepositoryParameters) DeepCopyInto(out *LocalCranRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCranRepositoryParameters.
func (in *LocalCranRepositoryParameters) DeepCopy() *LocalCranRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalCranRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCranRepositorySpec) DeepCopyInto(out *LocalCranRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCranRepositorySpec.
func (in *LocalCranRepositorySpec) DeepCopy() *LocalCranRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalCranRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalCranRepositoryStatus) DeepCopyInto(out *LocalCranRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalCranRepositoryStatus.
func (in *LocalCranRepositoryStatus) DeepCopy() *LocalCranRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalCranRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDebianRepository) DeepCopyInto(out *LocalDebianRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDebianRepository.
func (in *LocalDebianRepository) DeepCopy() *LocalDebianRepository {
	if in == nil {
		return nil
	}
	out := new(LocalDebianRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalDebianRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDebianRepositoryInitParameters) DeepCopyInto(out *LocalDebianRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.DdebSupported != nil {
		in, out := &in.DdebSupported, &out.DdebSupported
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IndexCompressionFormats != nil {
		in, out := &in.IndexCompressionFormats, &out.IndexCompressionFormats
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SecondaryKeypairRef != nil {
		in, out := &in.SecondaryKeypairRef, &out.SecondaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.TrivialLayout != nil {
		in, out := &in.TrivialLayout, &out.TrivialLayout
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDebianRepositoryInitParameters.
func (in *LocalDebianRepositoryInitParameters) DeepCopy() *LocalDebianRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalDebianRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDebianRepositoryList) DeepCopyInto(out *LocalDebianRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalDebianRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDebianRepositoryList.
func (in *LocalDebianRepositoryList) DeepCopy() *LocalDebianRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalDebianRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalDebianRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDebianRepositoryObservation) DeepCopyInto(out *LocalDebianRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.DdebSupported != nil {
		in, out := &in.DdebSupported, &out.DdebSupported
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IndexCompressionFormats != nil {
		in, out := &in.IndexCompressionFormats, &out.IndexCompressionFormats
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SecondaryKeypairRef != nil {
		in, out := &in.SecondaryKeypairRef, &out.SecondaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.TrivialLayout != nil {
		in, out := &in.TrivialLayout, &out.TrivialLayout
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDebianRepositoryObservation.
func (in *LocalDebianRepositoryObservation) DeepCopy() *LocalDebianRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalDebianRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDebianRepositoryParameters) DeepCopyInto(out *LocalDebianRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.DdebSupported != nil {
		in, out := &in.DdebSupported, &out.DdebSupported
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IndexCompressionFormats != nil {
		in, out := &in.IndexCompressionFormats, &out.IndexCompressionFormats
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SecondaryKeypairRef != nil {
		in, out := &in.SecondaryKeypairRef, &out.SecondaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.TrivialLayout != nil {
		in, out := &in.TrivialLayout, &out.TrivialLayout
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDebianRepositoryParameters.
func (in *LocalDebianRepositoryParameters) DeepCopy() *LocalDebianRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalDebianRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDebianRepositorySpec) DeepCopyInto(out *LocalDebianRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDebianRepositorySpec.
func (in *LocalDebianRepositorySpec) DeepCopy() *LocalDebianRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalDebianRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDebianRepositoryStatus) DeepCopyInto(out *LocalDebianRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDebianRepositoryStatus.
func (in *LocalDebianRepositoryStatus) DeepCopy() *LocalDebianRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalDebianRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV1Repository) DeepCopyInto(out *LocalDockerV1Repository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV1Repository.
func (in *LocalDockerV1Repository) DeepCopy() *LocalDockerV1Repository {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV1Repository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalDockerV1Repository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV1RepositoryInitParameters) DeepCopyInto(out *LocalDockerV1RepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV1RepositoryInitParameters.
func (in *LocalDockerV1RepositoryInitParameters) DeepCopy() *LocalDockerV1RepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV1RepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV1RepositoryList) DeepCopyInto(out *LocalDockerV1RepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalDockerV1Repository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV1RepositoryList.
func (in *LocalDockerV1RepositoryList) DeepCopy() *LocalDockerV1RepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV1RepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalDockerV1RepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV1RepositoryObservation) DeepCopyInto(out *LocalDockerV1RepositoryObservation) {
	*out = *in
	if in.APIVersion != nil {
		in, out := &in.APIVersion, &out.APIVersion
		*out = new(string)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockPushingSchema1 != nil {
		in, out := &in.BlockPushingSchema1, &out.BlockPushingSchema1
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueTags != nil {
		in, out := &in.MaxUniqueTags, &out.MaxUniqueTags
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.TagRetention != nil {
		in, out := &in.TagRetention, &out.TagRetention
		*out = new(float64)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV1RepositoryObservation.
func (in *LocalDockerV1RepositoryObservation) DeepCopy() *LocalDockerV1RepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV1RepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV1RepositoryParameters) DeepCopyInto(out *LocalDockerV1RepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV1RepositoryParameters.
func (in *LocalDockerV1RepositoryParameters) DeepCopy() *LocalDockerV1RepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV1RepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV1RepositorySpec) DeepCopyInto(out *LocalDockerV1RepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV1RepositorySpec.
func (in *LocalDockerV1RepositorySpec) DeepCopy() *LocalDockerV1RepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV1RepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV1RepositoryStatus) DeepCopyInto(out *LocalDockerV1RepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV1RepositoryStatus.
func (in *LocalDockerV1RepositoryStatus) DeepCopy() *LocalDockerV1RepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV1RepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV2Repository) DeepCopyInto(out *LocalDockerV2Repository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV2Repository.
func (in *LocalDockerV2Repository) DeepCopy() *LocalDockerV2Repository {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV2Repository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalDockerV2Repository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV2RepositoryInitParameters) DeepCopyInto(out *LocalDockerV2RepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockPushingSchema1 != nil {
		in, out := &in.BlockPushingSchema1, &out.BlockPushingSchema1
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueTags != nil {
		in, out := &in.MaxUniqueTags, &out.MaxUniqueTags
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.TagRetention != nil {
		in, out := &in.TagRetention, &out.TagRetention
		*out = new(float64)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV2RepositoryInitParameters.
func (in *LocalDockerV2RepositoryInitParameters) DeepCopy() *LocalDockerV2RepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV2RepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV2RepositoryList) DeepCopyInto(out *LocalDockerV2RepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalDockerV2Repository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV2RepositoryList.
func (in *LocalDockerV2RepositoryList) DeepCopy() *LocalDockerV2RepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV2RepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalDockerV2RepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV2RepositoryObservation) DeepCopyInto(out *LocalDockerV2RepositoryObservation) {
	*out = *in
	if in.APIVersion != nil {
		in, out := &in.APIVersion, &out.APIVersion
		*out = new(string)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockPushingSchema1 != nil {
		in, out := &in.BlockPushingSchema1, &out.BlockPushingSchema1
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueTags != nil {
		in, out := &in.MaxUniqueTags, &out.MaxUniqueTags
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.TagRetention != nil {
		in, out := &in.TagRetention, &out.TagRetention
		*out = new(float64)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV2RepositoryObservation.
func (in *LocalDockerV2RepositoryObservation) DeepCopy() *LocalDockerV2RepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV2RepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV2RepositoryParameters) DeepCopyInto(out *LocalDockerV2RepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockPushingSchema1 != nil {
		in, out := &in.BlockPushingSchema1, &out.BlockPushingSchema1
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueTags != nil {
		in, out := &in.MaxUniqueTags, &out.MaxUniqueTags
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.TagRetention != nil {
		in, out := &in.TagRetention, &out.TagRetention
		*out = new(float64)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV2RepositoryParameters.
func (in *LocalDockerV2RepositoryParameters) DeepCopy() *LocalDockerV2RepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV2RepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV2RepositorySpec) DeepCopyInto(out *LocalDockerV2RepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV2RepositorySpec.
func (in *LocalDockerV2RepositorySpec) DeepCopy() *LocalDockerV2RepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV2RepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalDockerV2RepositoryStatus) DeepCopyInto(out *LocalDockerV2RepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalDockerV2RepositoryStatus.
func (in *LocalDockerV2RepositoryStatus) DeepCopy() *LocalDockerV2RepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalDockerV2RepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGenericRepository) DeepCopyInto(out *LocalGenericRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGenericRepository.
func (in *LocalGenericRepository) DeepCopy() *LocalGenericRepository {
	if in == nil {
		return nil
	}
	out := new(LocalGenericRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalGenericRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGenericRepositoryInitParameters) DeepCopyInto(out *LocalGenericRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGenericRepositoryInitParameters.
func (in *LocalGenericRepositoryInitParameters) DeepCopy() *LocalGenericRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalGenericRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGenericRepositoryList) DeepCopyInto(out *LocalGenericRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalGenericRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGenericRepositoryList.
func (in *LocalGenericRepositoryList) DeepCopy() *LocalGenericRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalGenericRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalGenericRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGenericRepositoryObservation) DeepCopyInto(out *LocalGenericRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGenericRepositoryObservation.
func (in *LocalGenericRepositoryObservation) DeepCopy() *LocalGenericRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalGenericRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGenericRepositoryParameters) DeepCopyInto(out *LocalGenericRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGenericRepositoryParameters.
func (in *LocalGenericRepositoryParameters) DeepCopy() *LocalGenericRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalGenericRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGenericRepositorySpec) DeepCopyInto(out *LocalGenericRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGenericRepositorySpec.
func (in *LocalGenericRepositorySpec) DeepCopy() *LocalGenericRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalGenericRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGenericRepositoryStatus) DeepCopyInto(out *LocalGenericRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGenericRepositoryStatus.
func (in *LocalGenericRepositoryStatus) DeepCopy() *LocalGenericRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalGenericRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGradleRepository) DeepCopyInto(out *LocalGradleRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGradleRepository.
func (in *LocalGradleRepository) DeepCopy() *LocalGradleRepository {
	if in == nil {
		return nil
	}
	out := new(LocalGradleRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalGradleRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGradleRepositoryInitParameters) DeepCopyInto(out *LocalGradleRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGradleRepositoryInitParameters.
func (in *LocalGradleRepositoryInitParameters) DeepCopy() *LocalGradleRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalGradleRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGradleRepositoryList) DeepCopyInto(out *LocalGradleRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalGradleRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGradleRepositoryList.
func (in *LocalGradleRepositoryList) DeepCopy() *LocalGradleRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalGradleRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalGradleRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGradleRepositoryObservation) DeepCopyInto(out *LocalGradleRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGradleRepositoryObservation.
func (in *LocalGradleRepositoryObservation) DeepCopy() *LocalGradleRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalGradleRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGradleRepositoryParameters) DeepCopyInto(out *LocalGradleRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGradleRepositoryParameters.
func (in *LocalGradleRepositoryParameters) DeepCopy() *LocalGradleRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalGradleRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGradleRepositorySpec) DeepCopyInto(out *LocalGradleRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGradleRepositorySpec.
func (in *LocalGradleRepositorySpec) DeepCopy() *LocalGradleRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalGradleRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalGradleRepositoryStatus) DeepCopyInto(out *LocalGradleRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalGradleRepositoryStatus.
func (in *LocalGradleRepositoryStatus) DeepCopy() *LocalGradleRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalGradleRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalHuggingfacemlRepository) DeepCopyInto(out *LocalHuggingfacemlRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalHuggingfacemlRepository.
func (in *LocalHuggingfacemlRepository) DeepCopy() *LocalHuggingfacemlRepository {
	if in == nil {
		return nil
	}
	out := new(LocalHuggingfacemlRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalHuggingfacemlRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalHuggingfacemlRepositoryInitParameters) DeepCopyInto(out *LocalHuggingfacemlRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalHuggingfacemlRepositoryInitParameters.
func (in *LocalHuggingfacemlRepositoryInitParameters) DeepCopy() *LocalHuggingfacemlRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalHuggingfacemlRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalHuggingfacemlRepositoryList) DeepCopyInto(out *LocalHuggingfacemlRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalHuggingfacemlRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalHuggingfacemlRepositoryList.
func (in *LocalHuggingfacemlRepositoryList) DeepCopy() *LocalHuggingfacemlRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalHuggingfacemlRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalHuggingfacemlRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalHuggingfacemlRepositoryObservation) DeepCopyInto(out *LocalHuggingfacemlRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalHuggingfacemlRepositoryObservation.
func (in *LocalHuggingfacemlRepositoryObservation) DeepCopy() *LocalHuggingfacemlRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalHuggingfacemlRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalHuggingfacemlRepositoryParameters) DeepCopyInto(out *LocalHuggingfacemlRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalHuggingfacemlRepositoryParameters.
func (in *LocalHuggingfacemlRepositoryParameters) DeepCopy() *LocalHuggingfacemlRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalHuggingfacemlRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalHuggingfacemlRepositorySpec) DeepCopyInto(out *LocalHuggingfacemlRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalHuggingfacemlRepositorySpec.
func (in *LocalHuggingfacemlRepositorySpec) DeepCopy() *LocalHuggingfacemlRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalHuggingfacemlRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalHuggingfacemlRepositoryStatus) DeepCopyInto(out *LocalHuggingfacemlRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalHuggingfacemlRepositoryStatus.
func (in *LocalHuggingfacemlRepositoryStatus) DeepCopy() *LocalHuggingfacemlRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalHuggingfacemlRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalIvyRepository) DeepCopyInto(out *LocalIvyRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalIvyRepository.
func (in *LocalIvyRepository) DeepCopy() *LocalIvyRepository {
	if in == nil {
		return nil
	}
	out := new(LocalIvyRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalIvyRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalIvyRepositoryInitParameters) DeepCopyInto(out *LocalIvyRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalIvyRepositoryInitParameters.
func (in *LocalIvyRepositoryInitParameters) DeepCopy() *LocalIvyRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalIvyRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalIvyRepositoryList) DeepCopyInto(out *LocalIvyRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalIvyRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalIvyRepositoryList.
func (in *LocalIvyRepositoryList) DeepCopy() *LocalIvyRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalIvyRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalIvyRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalIvyRepositoryObservation) DeepCopyInto(out *LocalIvyRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalIvyRepositoryObservation.
func (in *LocalIvyRepositoryObservation) DeepCopy() *LocalIvyRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalIvyRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalIvyRepositoryParameters) DeepCopyInto(out *LocalIvyRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalIvyRepositoryParameters.
func (in *LocalIvyRepositoryParameters) DeepCopy() *LocalIvyRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalIvyRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalIvyRepositorySpec) DeepCopyInto(out *LocalIvyRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalIvyRepositorySpec.
func (in *LocalIvyRepositorySpec) DeepCopy() *LocalIvyRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalIvyRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalIvyRepositoryStatus) DeepCopyInto(out *LocalIvyRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalIvyRepositoryStatus.
func (in *LocalIvyRepositoryStatus) DeepCopy() *LocalIvyRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalIvyRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMachinelearningRepository) DeepCopyInto(out *LocalMachinelearningRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMachinelearningRepository.
func (in *LocalMachinelearningRepository) DeepCopy() *LocalMachinelearningRepository {
	if in == nil {
		return nil
	}
	out := new(LocalMachinelearningRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalMachinelearningRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMachinelearningRepositoryInitParameters) DeepCopyInto(out *LocalMachinelearningRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMachinelearningRepositoryInitParameters.
func (in *LocalMachinelearningRepositoryInitParameters) DeepCopy() *LocalMachinelearningRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalMachinelearningRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMachinelearningRepositoryList) DeepCopyInto(out *LocalMachinelearningRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalMachinelearningRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMachinelearningRepositoryList.
func (in *LocalMachinelearningRepositoryList) DeepCopy() *LocalMachinelearningRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalMachinelearningRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalMachinelearningRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMachinelearningRepositoryObservation) DeepCopyInto(out *LocalMachinelearningRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMachinelearningRepositoryObservation.
func (in *LocalMachinelearningRepositoryObservation) DeepCopy() *LocalMachinelearningRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalMachinelearningRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMachinelearningRepositoryParameters) DeepCopyInto(out *LocalMachinelearningRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMachinelearningRepositoryParameters.
func (in *LocalMachinelearningRepositoryParameters) DeepCopy() *LocalMachinelearningRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalMachinelearningRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMachinelearningRepositorySpec) DeepCopyInto(out *LocalMachinelearningRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMachinelearningRepositorySpec.
func (in *LocalMachinelearningRepositorySpec) DeepCopy() *LocalMachinelearningRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalMachinelearningRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMachinelearningRepositoryStatus) DeepCopyInto(out *LocalMachinelearningRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMachinelearningRepositoryStatus.
func (in *LocalMachinelearningRepositoryStatus) DeepCopy() *LocalMachinelearningRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalMachinelearningRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMavenRepository) DeepCopyInto(out *LocalMavenRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMavenRepository.
func (in *LocalMavenRepository) DeepCopy() *LocalMavenRepository {
	if in == nil {
		return nil
	}
	out := new(LocalMavenRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalMavenRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMavenRepositoryInitParameters) DeepCopyInto(out *LocalMavenRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMavenRepositoryInitParameters.
func (in *LocalMavenRepositoryInitParameters) DeepCopy() *LocalMavenRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalMavenRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMavenRepositoryList) DeepCopyInto(out *LocalMavenRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalMavenRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMavenRepositoryList.
func (in *LocalMavenRepositoryList) DeepCopy() *LocalMavenRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalMavenRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalMavenRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMavenRepositoryObservation) DeepCopyInto(out *LocalMavenRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMavenRepositoryObservation.
func (in *LocalMavenRepositoryObservation) DeepCopy() *LocalMavenRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalMavenRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMavenRepositoryParameters) DeepCopyInto(out *LocalMavenRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMavenRepositoryParameters.
func (in *LocalMavenRepositoryParameters) DeepCopy() *LocalMavenRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalMavenRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMavenRepositorySpec) DeepCopyInto(out *LocalMavenRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMavenRepositorySpec.
func (in *LocalMavenRepositorySpec) DeepCopy() *LocalMavenRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalMavenRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalMavenRepositoryStatus) DeepCopyInto(out *LocalMavenRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalMavenRepositoryStatus.
func (in *LocalMavenRepositoryStatus) DeepCopy() *LocalMavenRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalMavenRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNpmRepository) DeepCopyInto(out *LocalNpmRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNpmRepository.
func (in *LocalNpmRepository) DeepCopy() *LocalNpmRepository {
	if in == nil {
		return nil
	}
	out := new(LocalNpmRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalNpmRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNpmRepositoryInitParameters) DeepCopyInto(out *LocalNpmRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNpmRepositoryInitParameters.
func (in *LocalNpmRepositoryInitParameters) DeepCopy() *LocalNpmRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalNpmRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNpmRepositoryList) DeepCopyInto(out *LocalNpmRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalNpmRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNpmRepositoryList.
func (in *LocalNpmRepositoryList) DeepCopy() *LocalNpmRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalNpmRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalNpmRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNpmRepositoryObservation) DeepCopyInto(out *LocalNpmRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNpmRepositoryObservation.
func (in *LocalNpmRepositoryObservation) DeepCopy() *LocalNpmRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalNpmRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNpmRepositoryParameters) DeepCopyInto(out *LocalNpmRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNpmRepositoryParameters.
func (in *LocalNpmRepositoryParameters) DeepCopy() *LocalNpmRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalNpmRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNpmRepositorySpec) DeepCopyInto(out *LocalNpmRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNpmRepositorySpec.
func (in *LocalNpmRepositorySpec) DeepCopy() *LocalNpmRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalNpmRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNpmRepositoryStatus) DeepCopyInto(out *LocalNpmRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNpmRepositoryStatus.
func (in *LocalNpmRepositoryStatus) DeepCopy() *LocalNpmRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalNpmRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNugetRepository) DeepCopyInto(out *LocalNugetRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNugetRepository.
func (in *LocalNugetRepository) DeepCopy() *LocalNugetRepository {
	if in == nil {
		return nil
	}
	out := new(LocalNugetRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalNugetRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNugetRepositoryInitParameters) DeepCopyInto(out *LocalNugetRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ForceNugetAuthentication != nil {
		in, out := &in.ForceNugetAuthentication, &out.ForceNugetAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNugetRepositoryInitParameters.
func (in *LocalNugetRepositoryInitParameters) DeepCopy() *LocalNugetRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalNugetRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNugetRepositoryList) DeepCopyInto(out *LocalNugetRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalNugetRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNugetRepositoryList.
func (in *LocalNugetRepositoryList) DeepCopy() *LocalNugetRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalNugetRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalNugetRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNugetRepositoryObservation) DeepCopyInto(out *LocalNugetRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ForceNugetAuthentication != nil {
		in, out := &in.ForceNugetAuthentication, &out.ForceNugetAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNugetRepositoryObservation.
func (in *LocalNugetRepositoryObservation) DeepCopy() *LocalNugetRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalNugetRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNugetRepositoryParameters) DeepCopyInto(out *LocalNugetRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ForceNugetAuthentication != nil {
		in, out := &in.ForceNugetAuthentication, &out.ForceNugetAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNugetRepositoryParameters.
func (in *LocalNugetRepositoryParameters) DeepCopy() *LocalNugetRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalNugetRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNugetRepositorySpec) DeepCopyInto(out *LocalNugetRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNugetRepositorySpec.
func (in *LocalNugetRepositorySpec) DeepCopy() *LocalNugetRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalNugetRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalNugetRepositoryStatus) DeepCopyInto(out *LocalNugetRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalNugetRepositoryStatus.
func (in *LocalNugetRepositoryStatus) DeepCopy() *LocalNugetRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalNugetRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOCIRepository) DeepCopyInto(out *LocalOCIRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOCIRepository.
func (in *LocalOCIRepository) DeepCopy() *LocalOCIRepository {
	if in == nil {
		return nil
	}
	out := new(LocalOCIRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalOCIRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOCIRepositoryInitParameters) DeepCopyInto(out *LocalOCIRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueTags != nil {
		in, out := &in.MaxUniqueTags, &out.MaxUniqueTags
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.TagRetention != nil {
		in, out := &in.TagRetention, &out.TagRetention
		*out = new(float64)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOCIRepositoryInitParameters.
func (in *LocalOCIRepositoryInitParameters) DeepCopy() *LocalOCIRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalOCIRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOCIRepositoryList) DeepCopyInto(out *LocalOCIRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalOCIRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOCIRepositoryList.
func (in *LocalOCIRepositoryList) DeepCopy() *LocalOCIRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalOCIRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalOCIRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOCIRepositoryObservation) DeepCopyInto(out *LocalOCIRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueTags != nil {
		in, out := &in.MaxUniqueTags, &out.MaxUniqueTags
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.TagRetention != nil {
		in, out := &in.TagRetention, &out.TagRetention
		*out = new(float64)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOCIRepositoryObservation.
func (in *LocalOCIRepositoryObservation) DeepCopy() *LocalOCIRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalOCIRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOCIRepositoryParameters) DeepCopyInto(out *LocalOCIRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueTags != nil {
		in, out := &in.MaxUniqueTags, &out.MaxUniqueTags
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.TagRetention != nil {
		in, out := &in.TagRetention, &out.TagRetention
		*out = new(float64)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOCIRepositoryParameters.
func (in *LocalOCIRepositoryParameters) DeepCopy() *LocalOCIRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalOCIRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOCIRepositorySpec) DeepCopyInto(out *LocalOCIRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOCIRepositorySpec.
func (in *LocalOCIRepositorySpec) DeepCopy() *LocalOCIRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalOCIRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOCIRepositoryStatus) DeepCopyInto(out *LocalOCIRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOCIRepositoryStatus.
func (in *LocalOCIRepositoryStatus) DeepCopy() *LocalOCIRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalOCIRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOpkgRepository) DeepCopyInto(out *LocalOpkgRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOpkgRepository.
func (in *LocalOpkgRepository) DeepCopy() *LocalOpkgRepository {
	if in == nil {
		return nil
	}
	out := new(LocalOpkgRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalOpkgRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOpkgRepositoryInitParameters) DeepCopyInto(out *LocalOpkgRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOpkgRepositoryInitParameters.
func (in *LocalOpkgRepositoryInitParameters) DeepCopy() *LocalOpkgRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalOpkgRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOpkgRepositoryList) DeepCopyInto(out *LocalOpkgRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalOpkgRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOpkgRepositoryList.
func (in *LocalOpkgRepositoryList) DeepCopy() *LocalOpkgRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalOpkgRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalOpkgRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOpkgRepositoryObservation) DeepCopyInto(out *LocalOpkgRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOpkgRepositoryObservation.
func (in *LocalOpkgRepositoryObservation) DeepCopy() *LocalOpkgRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalOpkgRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOpkgRepositoryParameters) DeepCopyInto(out *LocalOpkgRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOpkgRepositoryParameters.
func (in *LocalOpkgRepositoryParameters) DeepCopy() *LocalOpkgRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalOpkgRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOpkgRepositorySpec) DeepCopyInto(out *LocalOpkgRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOpkgRepositorySpec.
func (in *LocalOpkgRepositorySpec) DeepCopy() *LocalOpkgRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalOpkgRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalOpkgRepositoryStatus) DeepCopyInto(out *LocalOpkgRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalOpkgRepositoryStatus.
func (in *LocalOpkgRepositoryStatus) DeepCopy() *LocalOpkgRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalOpkgRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPubRepository) DeepCopyInto(out *LocalPubRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPubRepository.
func (in *LocalPubRepository) DeepCopy() *LocalPubRepository {
	if in == nil {
		return nil
	}
	out := new(LocalPubRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalPubRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPubRepositoryInitParameters) DeepCopyInto(out *LocalPubRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPubRepositoryInitParameters.
func (in *LocalPubRepositoryInitParameters) DeepCopy() *LocalPubRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalPubRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPubRepositoryList) DeepCopyInto(out *LocalPubRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalPubRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPubRepositoryList.
func (in *LocalPubRepositoryList) DeepCopy() *LocalPubRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalPubRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalPubRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPubRepositoryObservation) DeepCopyInto(out *LocalPubRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPubRepositoryObservation.
func (in *LocalPubRepositoryObservation) DeepCopy() *LocalPubRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalPubRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPubRepositoryParameters) DeepCopyInto(out *LocalPubRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPubRepositoryParameters.
func (in *LocalPubRepositoryParameters) DeepCopy() *LocalPubRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalPubRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPubRepositorySpec) DeepCopyInto(out *LocalPubRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPubRepositorySpec.
func (in *LocalPubRepositorySpec) DeepCopy() *LocalPubRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalPubRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPubRepositoryStatus) DeepCopyInto(out *LocalPubRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPubRepositoryStatus.
func (in *LocalPubRepositoryStatus) DeepCopy() *LocalPubRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalPubRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPuppetRepository) DeepCopyInto(out *LocalPuppetRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPuppetRepository.
func (in *LocalPuppetRepository) DeepCopy() *LocalPuppetRepository {
	if in == nil {
		return nil
	}
	out := new(LocalPuppetRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalPuppetRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPuppetRepositoryInitParameters) DeepCopyInto(out *LocalPuppetRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPuppetRepositoryInitParameters.
func (in *LocalPuppetRepositoryInitParameters) DeepCopy() *LocalPuppetRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalPuppetRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPuppetRepositoryList) DeepCopyInto(out *LocalPuppetRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalPuppetRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPuppetRepositoryList.
func (in *LocalPuppetRepositoryList) DeepCopy() *LocalPuppetRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalPuppetRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalPuppetRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPuppetRepositoryObservation) DeepCopyInto(out *LocalPuppetRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPuppetRepositoryObservation.
func (in *LocalPuppetRepositoryObservation) DeepCopy() *LocalPuppetRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalPuppetRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPuppetRepositoryParameters) DeepCopyInto(out *LocalPuppetRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPuppetRepositoryParameters.
func (in *LocalPuppetRepositoryParameters) DeepCopy() *LocalPuppetRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalPuppetRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPuppetRepositorySpec) DeepCopyInto(out *LocalPuppetRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPuppetRepositorySpec.
func (in *LocalPuppetRepositorySpec) DeepCopy() *LocalPuppetRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalPuppetRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPuppetRepositoryStatus) DeepCopyInto(out *LocalPuppetRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPuppetRepositoryStatus.
func (in *LocalPuppetRepositoryStatus) DeepCopy() *LocalPuppetRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalPuppetRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPypiRepository) DeepCopyInto(out *LocalPypiRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPypiRepository.
func (in *LocalPypiRepository) DeepCopy() *LocalPypiRepository {
	if in == nil {
		return nil
	}
	out := new(LocalPypiRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalPypiRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPypiRepositoryInitParameters) DeepCopyInto(out *LocalPypiRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPypiRepositoryInitParameters.
func (in *LocalPypiRepositoryInitParameters) DeepCopy() *LocalPypiRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalPypiRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPypiRepositoryList) DeepCopyInto(out *LocalPypiRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalPypiRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPypiRepositoryList.
func (in *LocalPypiRepositoryList) DeepCopy() *LocalPypiRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalPypiRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalPypiRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPypiRepositoryObservation) DeepCopyInto(out *LocalPypiRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPypiRepositoryObservation.
func (in *LocalPypiRepositoryObservation) DeepCopy() *LocalPypiRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalPypiRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPypiRepositoryParameters) DeepCopyInto(out *LocalPypiRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPypiRepositoryParameters.
func (in *LocalPypiRepositoryParameters) DeepCopy() *LocalPypiRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalPypiRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPypiRepositorySpec) DeepCopyInto(out *LocalPypiRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPypiRepositorySpec.
func (in *LocalPypiRepositorySpec) DeepCopy() *LocalPypiRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalPypiRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalPypiRepositoryStatus) DeepCopyInto(out *LocalPypiRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalPypiRepositoryStatus.
func (in *LocalPypiRepositoryStatus) DeepCopy() *LocalPypiRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalPypiRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalRPMRepository) DeepCopyInto(out *LocalRPMRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalRPMRepository.
func (in *LocalRPMRepository) DeepCopy() *LocalRPMRepository {
	if in == nil {
		return nil
	}
	out := new(LocalRPMRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalRPMRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalRPMRepositoryInitParameters) DeepCopyInto(out *LocalRPMRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CalculateYumMetadata != nil {
		in, out := &in.CalculateYumMetadata, &out.CalculateYumMetadata
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableFileListsIndexing != nil {
		in, out := &in.EnableFileListsIndexing, &out.EnableFileListsIndexing
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SecondaryKeypairRef != nil {
		in, out := &in.SecondaryKeypairRef, &out.SecondaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
	if in.YumGroupFileNames != nil {
		in, out := &in.YumGroupFileNames, &out.YumGroupFileNames
		*out = new(string)
		**out = **in
	}
	if in.YumRootDepth != nil {
		in, out := &in.YumRootDepth, &out.YumRootDepth
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalRPMRepositoryInitParameters.
func (in *LocalRPMRepositoryInitParameters) DeepCopy() *LocalRPMRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalRPMRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalRPMRepositoryList) DeepCopyInto(out *LocalRPMRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalRPMRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalRPMRepositoryList.
func (in *LocalRPMRepositoryList) DeepCopy() *LocalRPMRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalRPMRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalRPMRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalRPMRepositoryObservation) DeepCopyInto(out *LocalRPMRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CalculateYumMetadata != nil {
		in, out := &in.CalculateYumMetadata, &out.CalculateYumMetadata
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableFileListsIndexing != nil {
		in, out := &in.EnableFileListsIndexing, &out.EnableFileListsIndexing
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SecondaryKeypairRef != nil {
		in, out := &in.SecondaryKeypairRef, &out.SecondaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
	if in.YumGroupFileNames != nil {
		in, out := &in.YumGroupFileNames, &out.YumGroupFileNames
		*out = new(string)
		**out = **in
	}
	if in.YumRootDepth != nil {
		in, out := &in.YumRootDepth, &out.YumRootDepth
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalRPMRepositoryObservation.
func (in *LocalRPMRepositoryObservation) DeepCopy() *LocalRPMRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalRPMRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalRPMRepositoryParameters) DeepCopyInto(out *LocalRPMRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CalculateYumMetadata != nil {
		in, out := &in.CalculateYumMetadata, &out.CalculateYumMetadata
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableFileListsIndexing != nil {
		in, out := &in.EnableFileListsIndexing, &out.EnableFileListsIndexing
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PrimaryKeypairRef != nil {
		in, out := &in.PrimaryKeypairRef, &out.PrimaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SecondaryKeypairRef != nil {
		in, out := &in.SecondaryKeypairRef, &out.SecondaryKeypairRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
	if in.YumGroupFileNames != nil {
		in, out := &in.YumGroupFileNames, &out.YumGroupFileNames
		*out = new(string)
		**out = **in
	}
	if in.YumRootDepth != nil {
		in, out := &in.YumRootDepth, &out.YumRootDepth
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalRPMRepositoryParameters.
func (in *LocalRPMRepositoryParameters) DeepCopy() *LocalRPMRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalRPMRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalRPMRepositorySpec) DeepCopyInto(out *LocalRPMRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalRPMRepositorySpec.
func (in *LocalRPMRepositorySpec) DeepCopy() *LocalRPMRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalRPMRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalRPMRepositoryStatus) DeepCopyInto(out *LocalRPMRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalRPMRepositoryStatus.
func (in *LocalRPMRepositoryStatus) DeepCopy() *LocalRPMRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalRPMRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSbtRepository) DeepCopyInto(out *LocalSbtRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSbtRepository.
func (in *LocalSbtRepository) DeepCopy() *LocalSbtRepository {
	if in == nil {
		return nil
	}
	out := new(LocalSbtRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalSbtRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSbtRepositoryInitParameters) DeepCopyInto(out *LocalSbtRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSbtRepositoryInitParameters.
func (in *LocalSbtRepositoryInitParameters) DeepCopy() *LocalSbtRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalSbtRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSbtRepositoryList) DeepCopyInto(out *LocalSbtRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalSbtRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSbtRepositoryList.
func (in *LocalSbtRepositoryList) DeepCopy() *LocalSbtRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalSbtRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalSbtRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSbtRepositoryObservation) DeepCopyInto(out *LocalSbtRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSbtRepositoryObservation.
func (in *LocalSbtRepositoryObservation) DeepCopy() *LocalSbtRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalSbtRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSbtRepositoryParameters) DeepCopyInto(out *LocalSbtRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ChecksumPolicyType != nil {
		in, out := &in.ChecksumPolicyType, &out.ChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.SnapshotVersionBehavior != nil {
		in, out := &in.SnapshotVersionBehavior, &out.SnapshotVersionBehavior
		*out = new(string)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSbtRepositoryParameters.
func (in *LocalSbtRepositoryParameters) DeepCopy() *LocalSbtRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalSbtRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSbtRepositorySpec) DeepCopyInto(out *LocalSbtRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSbtRepositorySpec.
func (in *LocalSbtRepositorySpec) DeepCopy() *LocalSbtRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalSbtRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSbtRepositoryStatus) DeepCopyInto(out *LocalSbtRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSbtRepositoryStatus.
func (in *LocalSbtRepositoryStatus) DeepCopy() *LocalSbtRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalSbtRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSwiftRepository) DeepCopyInto(out *LocalSwiftRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSwiftRepository.
func (in *LocalSwiftRepository) DeepCopy() *LocalSwiftRepository {
	if in == nil {
		return nil
	}
	out := new(LocalSwiftRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalSwiftRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSwiftRepositoryInitParameters) DeepCopyInto(out *LocalSwiftRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSwiftRepositoryInitParameters.
func (in *LocalSwiftRepositoryInitParameters) DeepCopy() *LocalSwiftRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalSwiftRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSwiftRepositoryList) DeepCopyInto(out *LocalSwiftRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalSwiftRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSwiftRepositoryList.
func (in *LocalSwiftRepositoryList) DeepCopy() *LocalSwiftRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalSwiftRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalSwiftRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSwiftRepositoryObservation) DeepCopyInto(out *LocalSwiftRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSwiftRepositoryObservation.
func (in *LocalSwiftRepositoryObservation) DeepCopy() *LocalSwiftRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalSwiftRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSwiftRepositoryParameters) DeepCopyInto(out *LocalSwiftRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSwiftRepositoryParameters.
func (in *LocalSwiftRepositoryParameters) DeepCopy() *LocalSwiftRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalSwiftRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSwiftRepositorySpec) DeepCopyInto(out *LocalSwiftRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSwiftRepositorySpec.
func (in *LocalSwiftRepositorySpec) DeepCopy() *LocalSwiftRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalSwiftRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalSwiftRepositoryStatus) DeepCopyInto(out *LocalSwiftRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalSwiftRepositoryStatus.
func (in *LocalSwiftRepositoryStatus) DeepCopy() *LocalSwiftRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalSwiftRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformModuleRepository) DeepCopyInto(out *LocalTerraformModuleRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformModuleRepository.
func (in *LocalTerraformModuleRepository) DeepCopy() *LocalTerraformModuleRepository {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformModuleRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalTerraformModuleRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformModuleRepositoryInitParameters) DeepCopyInto(out *LocalTerraformModuleRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformModuleRepositoryInitParameters.
func (in *LocalTerraformModuleRepositoryInitParameters) DeepCopy() *LocalTerraformModuleRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformModuleRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformModuleRepositoryList) DeepCopyInto(out *LocalTerraformModuleRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalTerraformModuleRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformModuleRepositoryList.
func (in *LocalTerraformModuleRepositoryList) DeepCopy() *LocalTerraformModuleRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformModuleRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalTerraformModuleRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformModuleRepositoryObservation) DeepCopyInto(out *LocalTerraformModuleRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformModuleRepositoryObservation.
func (in *LocalTerraformModuleRepositoryObservation) DeepCopy() *LocalTerraformModuleRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformModuleRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformModuleRepositoryParameters) DeepCopyInto(out *LocalTerraformModuleRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformModuleRepositoryParameters.
func (in *LocalTerraformModuleRepositoryParameters) DeepCopy() *LocalTerraformModuleRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformModuleRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformModuleRepositorySpec) DeepCopyInto(out *LocalTerraformModuleRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformModuleRepositorySpec.
func (in *LocalTerraformModuleRepositorySpec) DeepCopy() *LocalTerraformModuleRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformModuleRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformModuleRepositoryStatus) DeepCopyInto(out *LocalTerraformModuleRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformModuleRepositoryStatus.
func (in *LocalTerraformModuleRepositoryStatus) DeepCopy() *LocalTerraformModuleRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformModuleRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformProviderRepository) DeepCopyInto(out *LocalTerraformProviderRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformProviderRepository.
func (in *LocalTerraformProviderRepository) DeepCopy() *LocalTerraformProviderRepository {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformProviderRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalTerraformProviderRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformProviderRepositoryInitParameters) DeepCopyInto(out *LocalTerraformProviderRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformProviderRepositoryInitParameters.
func (in *LocalTerraformProviderRepositoryInitParameters) DeepCopy() *LocalTerraformProviderRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformProviderRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformProviderRepositoryList) DeepCopyInto(out *LocalTerraformProviderRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalTerraformProviderRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformProviderRepositoryList.
func (in *LocalTerraformProviderRepositoryList) DeepCopy() *LocalTerraformProviderRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformProviderRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalTerraformProviderRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformProviderRepositoryObservation) DeepCopyInto(out *LocalTerraformProviderRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformProviderRepositoryObservation.
func (in *LocalTerraformProviderRepositoryObservation) DeepCopy() *LocalTerraformProviderRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformProviderRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformProviderRepositoryParameters) DeepCopyInto(out *LocalTerraformProviderRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformProviderRepositoryParameters.
func (in *LocalTerraformProviderRepositoryParameters) DeepCopy() *LocalTerraformProviderRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformProviderRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformProviderRepositorySpec) DeepCopyInto(out *LocalTerraformProviderRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformProviderRepositorySpec.
func (in *LocalTerraformProviderRepositorySpec) DeepCopy() *LocalTerraformProviderRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformProviderRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformProviderRepositoryStatus) DeepCopyInto(out *LocalTerraformProviderRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformProviderRepositoryStatus.
func (in *LocalTerraformProviderRepositoryStatus) DeepCopy() *LocalTerraformProviderRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformProviderRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformbackendRepository) DeepCopyInto(out *LocalTerraformbackendRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformbackendRepository.
func (in *LocalTerraformbackendRepository) DeepCopy() *LocalTerraformbackendRepository {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformbackendRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalTerraformbackendRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformbackendRepositoryInitParameters) DeepCopyInto(out *LocalTerraformbackendRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformbackendRepositoryInitParameters.
func (in *LocalTerraformbackendRepositoryInitParameters) DeepCopy() *LocalTerraformbackendRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformbackendRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformbackendRepositoryList) DeepCopyInto(out *LocalTerraformbackendRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalTerraformbackendRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformbackendRepositoryList.
func (in *LocalTerraformbackendRepositoryList) DeepCopy() *LocalTerraformbackendRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformbackendRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalTerraformbackendRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformbackendRepositoryObservation) DeepCopyInto(out *LocalTerraformbackendRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformbackendRepositoryObservation.
func (in *LocalTerraformbackendRepositoryObservation) DeepCopy() *LocalTerraformbackendRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformbackendRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformbackendRepositoryParameters) DeepCopyInto(out *LocalTerraformbackendRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformbackendRepositoryParameters.
func (in *LocalTerraformbackendRepositoryParameters) DeepCopy() *LocalTerraformbackendRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformbackendRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformbackendRepositorySpec) DeepCopyInto(out *LocalTerraformbackendRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformbackendRepositorySpec.
func (in *LocalTerraformbackendRepositorySpec) DeepCopy() *LocalTerraformbackendRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformbackendRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalTerraformbackendRepositoryStatus) DeepCopyInto(out *LocalTerraformbackendRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalTerraformbackendRepositoryStatus.
func (in *LocalTerraformbackendRepositoryStatus) DeepCopy() *LocalTerraformbackendRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalTerraformbackendRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalVagrantRepository) DeepCopyInto(out *LocalVagrantRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalVagrantRepository.
func (in *LocalVagrantRepository) DeepCopy() *LocalVagrantRepository {
	if in == nil {
		return nil
	}
	out := new(LocalVagrantRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalVagrantRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalVagrantRepositoryInitParameters) DeepCopyInto(out *LocalVagrantRepositoryInitParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalVagrantRepositoryInitParameters.
func (in *LocalVagrantRepositoryInitParameters) DeepCopy() *LocalVagrantRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(LocalVagrantRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalVagrantRepositoryList) DeepCopyInto(out *LocalVagrantRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]LocalVagrantRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalVagrantRepositoryList.
func (in *LocalVagrantRepositoryList) DeepCopy() *LocalVagrantRepositoryList {
	if in == nil {
		return nil
	}
	out := new(LocalVagrantRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *LocalVagrantRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalVagrantRepositoryObservation) DeepCopyInto(out *LocalVagrantRepositoryObservation) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalVagrantRepositoryObservation.
func (in *LocalVagrantRepositoryObservation) DeepCopy() *LocalVagrantRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(LocalVagrantRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalVagrantRepositoryParameters) DeepCopyInto(out *LocalVagrantRepositoryParameters) {
	*out = *in
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalVagrantRepositoryParameters.
func (in *LocalVagrantRepositoryParameters) DeepCopy() *LocalVagrantRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(LocalVagrantRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalVagrantRepositorySpec) DeepCopyInto(out *LocalVagrantRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalVagrantRepositorySpec.
func (in *LocalVagrantRepositorySpec) DeepCopy() *LocalVagrantRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(LocalVagrantRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *LocalVagrantRepositoryStatus) DeepCopyInto(out *LocalVagrantRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new LocalVagrantRepositoryStatus.
func (in *LocalVagrantRepositoryStatus) DeepCopy() *LocalVagrantRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(LocalVagrantRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAlpineRepository) DeepCopyInto(out *RemoteAlpineRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAlpineRepository.
func (in *RemoteAlpineRepository) DeepCopy() *RemoteAlpineRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteAlpineRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteAlpineRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAlpineRepositoryInitParameters) DeepCopyInto(out *RemoteAlpineRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAlpineRepositoryInitParameters.
func (in *RemoteAlpineRepositoryInitParameters) DeepCopy() *RemoteAlpineRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteAlpineRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAlpineRepositoryList) DeepCopyInto(out *RemoteAlpineRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteAlpineRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAlpineRepositoryList.
func (in *RemoteAlpineRepositoryList) DeepCopy() *RemoteAlpineRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteAlpineRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteAlpineRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAlpineRepositoryObservation) DeepCopyInto(out *RemoteAlpineRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAlpineRepositoryObservation.
func (in *RemoteAlpineRepositoryObservation) DeepCopy() *RemoteAlpineRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteAlpineRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAlpineRepositoryParameters) DeepCopyInto(out *RemoteAlpineRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAlpineRepositoryParameters.
func (in *RemoteAlpineRepositoryParameters) DeepCopy() *RemoteAlpineRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteAlpineRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAlpineRepositorySpec) DeepCopyInto(out *RemoteAlpineRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAlpineRepositorySpec.
func (in *RemoteAlpineRepositorySpec) DeepCopy() *RemoteAlpineRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteAlpineRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAlpineRepositoryStatus) DeepCopyInto(out *RemoteAlpineRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAlpineRepositoryStatus.
func (in *RemoteAlpineRepositoryStatus) DeepCopy() *RemoteAlpineRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteAlpineRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAnsibleRepository) DeepCopyInto(out *RemoteAnsibleRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAnsibleRepository.
func (in *RemoteAnsibleRepository) DeepCopy() *RemoteAnsibleRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteAnsibleRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteAnsibleRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAnsibleRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteAnsibleRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAnsibleRepositoryContentSynchronisationInitParameters.
func (in *RemoteAnsibleRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteAnsibleRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteAnsibleRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAnsibleRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteAnsibleRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAnsibleRepositoryContentSynchronisationObservation.
func (in *RemoteAnsibleRepositoryContentSynchronisationObservation) DeepCopy() *RemoteAnsibleRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteAnsibleRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAnsibleRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteAnsibleRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAnsibleRepositoryContentSynchronisationParameters.
func (in *RemoteAnsibleRepositoryContentSynchronisationParameters) DeepCopy() *RemoteAnsibleRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteAnsibleRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAnsibleRepositoryInitParameters) DeepCopyInto(out *RemoteAnsibleRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteAnsibleRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAnsibleRepositoryInitParameters.
func (in *RemoteAnsibleRepositoryInitParameters) DeepCopy() *RemoteAnsibleRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteAnsibleRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAnsibleRepositoryList) DeepCopyInto(out *RemoteAnsibleRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteAnsibleRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAnsibleRepositoryList.
func (in *RemoteAnsibleRepositoryList) DeepCopy() *RemoteAnsibleRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteAnsibleRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteAnsibleRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAnsibleRepositoryObservation) DeepCopyInto(out *RemoteAnsibleRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteAnsibleRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAnsibleRepositoryObservation.
func (in *RemoteAnsibleRepositoryObservation) DeepCopy() *RemoteAnsibleRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteAnsibleRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAnsibleRepositoryParameters) DeepCopyInto(out *RemoteAnsibleRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteAnsibleRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAnsibleRepositoryParameters.
func (in *RemoteAnsibleRepositoryParameters) DeepCopy() *RemoteAnsibleRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteAnsibleRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAnsibleRepositorySpec) DeepCopyInto(out *RemoteAnsibleRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAnsibleRepositorySpec.
func (in *RemoteAnsibleRepositorySpec) DeepCopy() *RemoteAnsibleRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteAnsibleRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteAnsibleRepositoryStatus) DeepCopyInto(out *RemoteAnsibleRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteAnsibleRepositoryStatus.
func (in *RemoteAnsibleRepositoryStatus) DeepCopy() *RemoteAnsibleRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteAnsibleRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteBowerRepository) DeepCopyInto(out *RemoteBowerRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteBowerRepository.
func (in *RemoteBowerRepository) DeepCopy() *RemoteBowerRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteBowerRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteBowerRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteBowerRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteBowerRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteBowerRepositoryContentSynchronisationInitParameters.
func (in *RemoteBowerRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteBowerRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteBowerRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteBowerRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteBowerRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteBowerRepositoryContentSynchronisationObservation.
func (in *RemoteBowerRepositoryContentSynchronisationObservation) DeepCopy() *RemoteBowerRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteBowerRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteBowerRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteBowerRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteBowerRepositoryContentSynchronisationParameters.
func (in *RemoteBowerRepositoryContentSynchronisationParameters) DeepCopy() *RemoteBowerRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteBowerRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteBowerRepositoryInitParameters) DeepCopyInto(out *RemoteBowerRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BowerRegistryURL != nil {
		in, out := &in.BowerRegistryURL, &out.BowerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteBowerRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteBowerRepositoryInitParameters.
func (in *RemoteBowerRepositoryInitParameters) DeepCopy() *RemoteBowerRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteBowerRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteBowerRepositoryList) DeepCopyInto(out *RemoteBowerRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteBowerRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteBowerRepositoryList.
func (in *RemoteBowerRepositoryList) DeepCopy() *RemoteBowerRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteBowerRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteBowerRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteBowerRepositoryObservation) DeepCopyInto(out *RemoteBowerRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BowerRegistryURL != nil {
		in, out := &in.BowerRegistryURL, &out.BowerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteBowerRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteBowerRepositoryObservation.
func (in *RemoteBowerRepositoryObservation) DeepCopy() *RemoteBowerRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteBowerRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteBowerRepositoryParameters) DeepCopyInto(out *RemoteBowerRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BowerRegistryURL != nil {
		in, out := &in.BowerRegistryURL, &out.BowerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteBowerRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteBowerRepositoryParameters.
func (in *RemoteBowerRepositoryParameters) DeepCopy() *RemoteBowerRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteBowerRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteBowerRepositorySpec) DeepCopyInto(out *RemoteBowerRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteBowerRepositorySpec.
func (in *RemoteBowerRepositorySpec) DeepCopy() *RemoteBowerRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteBowerRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteBowerRepositoryStatus) DeepCopyInto(out *RemoteBowerRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteBowerRepositoryStatus.
func (in *RemoteBowerRepositoryStatus) DeepCopy() *RemoteBowerRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteBowerRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCargoRepository) DeepCopyInto(out *RemoteCargoRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCargoRepository.
func (in *RemoteCargoRepository) DeepCopy() *RemoteCargoRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteCargoRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteCargoRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCargoRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteCargoRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCargoRepositoryContentSynchronisationInitParameters.
func (in *RemoteCargoRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteCargoRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCargoRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCargoRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteCargoRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCargoRepositoryContentSynchronisationObservation.
func (in *RemoteCargoRepositoryContentSynchronisationObservation) DeepCopy() *RemoteCargoRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteCargoRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCargoRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteCargoRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCargoRepositoryContentSynchronisationParameters.
func (in *RemoteCargoRepositoryContentSynchronisationParameters) DeepCopy() *RemoteCargoRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCargoRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCargoRepositoryInitParameters) DeepCopyInto(out *RemoteCargoRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.AnonymousAccess != nil {
		in, out := &in.AnonymousAccess, &out.AnonymousAccess
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCargoRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableSparseIndex != nil {
		in, out := &in.EnableSparseIndex, &out.EnableSparseIndex
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.GitRegistryURL != nil {
		in, out := &in.GitRegistryURL, &out.GitRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCargoRepositoryInitParameters.
func (in *RemoteCargoRepositoryInitParameters) DeepCopy() *RemoteCargoRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCargoRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCargoRepositoryList) DeepCopyInto(out *RemoteCargoRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteCargoRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCargoRepositoryList.
func (in *RemoteCargoRepositoryList) DeepCopy() *RemoteCargoRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteCargoRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteCargoRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCargoRepositoryObservation) DeepCopyInto(out *RemoteCargoRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.AnonymousAccess != nil {
		in, out := &in.AnonymousAccess, &out.AnonymousAccess
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCargoRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableSparseIndex != nil {
		in, out := &in.EnableSparseIndex, &out.EnableSparseIndex
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.GitRegistryURL != nil {
		in, out := &in.GitRegistryURL, &out.GitRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCargoRepositoryObservation.
func (in *RemoteCargoRepositoryObservation) DeepCopy() *RemoteCargoRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteCargoRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCargoRepositoryParameters) DeepCopyInto(out *RemoteCargoRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.AnonymousAccess != nil {
		in, out := &in.AnonymousAccess, &out.AnonymousAccess
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCargoRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableSparseIndex != nil {
		in, out := &in.EnableSparseIndex, &out.EnableSparseIndex
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.GitRegistryURL != nil {
		in, out := &in.GitRegistryURL, &out.GitRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCargoRepositoryParameters.
func (in *RemoteCargoRepositoryParameters) DeepCopy() *RemoteCargoRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCargoRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCargoRepositorySpec) DeepCopyInto(out *RemoteCargoRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCargoRepositorySpec.
func (in *RemoteCargoRepositorySpec) DeepCopy() *RemoteCargoRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteCargoRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCargoRepositoryStatus) DeepCopyInto(out *RemoteCargoRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCargoRepositoryStatus.
func (in *RemoteCargoRepositoryStatus) DeepCopy() *RemoteCargoRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteCargoRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteChefRepository) DeepCopyInto(out *RemoteChefRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteChefRepository.
func (in *RemoteChefRepository) DeepCopy() *RemoteChefRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteChefRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteChefRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteChefRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteChefRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteChefRepositoryContentSynchronisationInitParameters.
func (in *RemoteChefRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteChefRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteChefRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteChefRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteChefRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteChefRepositoryContentSynchronisationObservation.
func (in *RemoteChefRepositoryContentSynchronisationObservation) DeepCopy() *RemoteChefRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteChefRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteChefRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteChefRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteChefRepositoryContentSynchronisationParameters.
func (in *RemoteChefRepositoryContentSynchronisationParameters) DeepCopy() *RemoteChefRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteChefRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteChefRepositoryInitParameters) DeepCopyInto(out *RemoteChefRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteChefRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteChefRepositoryInitParameters.
func (in *RemoteChefRepositoryInitParameters) DeepCopy() *RemoteChefRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteChefRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteChefRepositoryList) DeepCopyInto(out *RemoteChefRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteChefRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteChefRepositoryList.
func (in *RemoteChefRepositoryList) DeepCopy() *RemoteChefRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteChefRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteChefRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteChefRepositoryObservation) DeepCopyInto(out *RemoteChefRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteChefRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteChefRepositoryObservation.
func (in *RemoteChefRepositoryObservation) DeepCopy() *RemoteChefRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteChefRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteChefRepositoryParameters) DeepCopyInto(out *RemoteChefRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteChefRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteChefRepositoryParameters.
func (in *RemoteChefRepositoryParameters) DeepCopy() *RemoteChefRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteChefRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteChefRepositorySpec) DeepCopyInto(out *RemoteChefRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteChefRepositorySpec.
func (in *RemoteChefRepositorySpec) DeepCopy() *RemoteChefRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteChefRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteChefRepositoryStatus) DeepCopyInto(out *RemoteChefRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteChefRepositoryStatus.
func (in *RemoteChefRepositoryStatus) DeepCopy() *RemoteChefRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteChefRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCocoapodsRepository) DeepCopyInto(out *RemoteCocoapodsRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCocoapodsRepository.
func (in *RemoteCocoapodsRepository) DeepCopy() *RemoteCocoapodsRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteCocoapodsRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteCocoapodsRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCocoapodsRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteCocoapodsRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCocoapodsRepositoryContentSynchronisationInitParameters.
func (in *RemoteCocoapodsRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteCocoapodsRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCocoapodsRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCocoapodsRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteCocoapodsRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCocoapodsRepositoryContentSynchronisationObservation.
func (in *RemoteCocoapodsRepositoryContentSynchronisationObservation) DeepCopy() *RemoteCocoapodsRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteCocoapodsRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCocoapodsRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteCocoapodsRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCocoapodsRepositoryContentSynchronisationParameters.
func (in *RemoteCocoapodsRepositoryContentSynchronisationParameters) DeepCopy() *RemoteCocoapodsRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCocoapodsRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCocoapodsRepositoryInitParameters) DeepCopyInto(out *RemoteCocoapodsRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCocoapodsRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PodsSpecsRepoURL != nil {
		in, out := &in.PodsSpecsRepoURL, &out.PodsSpecsRepoURL
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCocoapodsRepositoryInitParameters.
func (in *RemoteCocoapodsRepositoryInitParameters) DeepCopy() *RemoteCocoapodsRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCocoapodsRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCocoapodsRepositoryList) DeepCopyInto(out *RemoteCocoapodsRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteCocoapodsRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCocoapodsRepositoryList.
func (in *RemoteCocoapodsRepositoryList) DeepCopy() *RemoteCocoapodsRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteCocoapodsRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteCocoapodsRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCocoapodsRepositoryObservation) DeepCopyInto(out *RemoteCocoapodsRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCocoapodsRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PodsSpecsRepoURL != nil {
		in, out := &in.PodsSpecsRepoURL, &out.PodsSpecsRepoURL
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCocoapodsRepositoryObservation.
func (in *RemoteCocoapodsRepositoryObservation) DeepCopy() *RemoteCocoapodsRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteCocoapodsRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCocoapodsRepositoryParameters) DeepCopyInto(out *RemoteCocoapodsRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCocoapodsRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PodsSpecsRepoURL != nil {
		in, out := &in.PodsSpecsRepoURL, &out.PodsSpecsRepoURL
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCocoapodsRepositoryParameters.
func (in *RemoteCocoapodsRepositoryParameters) DeepCopy() *RemoteCocoapodsRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCocoapodsRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCocoapodsRepositorySpec) DeepCopyInto(out *RemoteCocoapodsRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCocoapodsRepositorySpec.
func (in *RemoteCocoapodsRepositorySpec) DeepCopy() *RemoteCocoapodsRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteCocoapodsRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCocoapodsRepositoryStatus) DeepCopyInto(out *RemoteCocoapodsRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCocoapodsRepositoryStatus.
func (in *RemoteCocoapodsRepositoryStatus) DeepCopy() *RemoteCocoapodsRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteCocoapodsRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteComposerRepository) DeepCopyInto(out *RemoteComposerRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteComposerRepository.
func (in *RemoteComposerRepository) DeepCopy() *RemoteComposerRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteComposerRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteComposerRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteComposerRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteComposerRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteComposerRepositoryContentSynchronisationInitParameters.
func (in *RemoteComposerRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteComposerRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteComposerRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteComposerRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteComposerRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteComposerRepositoryContentSynchronisationObservation.
func (in *RemoteComposerRepositoryContentSynchronisationObservation) DeepCopy() *RemoteComposerRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteComposerRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteComposerRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteComposerRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteComposerRepositoryContentSynchronisationParameters.
func (in *RemoteComposerRepositoryContentSynchronisationParameters) DeepCopy() *RemoteComposerRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteComposerRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteComposerRepositoryInitParameters) DeepCopyInto(out *RemoteComposerRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ComposerRegistryURL != nil {
		in, out := &in.ComposerRegistryURL, &out.ComposerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteComposerRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteComposerRepositoryInitParameters.
func (in *RemoteComposerRepositoryInitParameters) DeepCopy() *RemoteComposerRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteComposerRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteComposerRepositoryList) DeepCopyInto(out *RemoteComposerRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteComposerRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteComposerRepositoryList.
func (in *RemoteComposerRepositoryList) DeepCopy() *RemoteComposerRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteComposerRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteComposerRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteComposerRepositoryObservation) DeepCopyInto(out *RemoteComposerRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ComposerRegistryURL != nil {
		in, out := &in.ComposerRegistryURL, &out.ComposerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteComposerRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteComposerRepositoryObservation.
func (in *RemoteComposerRepositoryObservation) DeepCopy() *RemoteComposerRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteComposerRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteComposerRepositoryParameters) DeepCopyInto(out *RemoteComposerRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ComposerRegistryURL != nil {
		in, out := &in.ComposerRegistryURL, &out.ComposerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteComposerRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteComposerRepositoryParameters.
func (in *RemoteComposerRepositoryParameters) DeepCopy() *RemoteComposerRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteComposerRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteComposerRepositorySpec) DeepCopyInto(out *RemoteComposerRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteComposerRepositorySpec.
func (in *RemoteComposerRepositorySpec) DeepCopy() *RemoteComposerRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteComposerRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteComposerRepositoryStatus) DeepCopyInto(out *RemoteComposerRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteComposerRepositoryStatus.
func (in *RemoteComposerRepositoryStatus) DeepCopy() *RemoteComposerRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteComposerRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCondaRepository) DeepCopyInto(out *RemoteCondaRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCondaRepository.
func (in *RemoteCondaRepository) DeepCopy() *RemoteCondaRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteCondaRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteCondaRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCondaRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteCondaRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCondaRepositoryContentSynchronisationInitParameters.
func (in *RemoteCondaRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteCondaRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCondaRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCondaRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteCondaRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCondaRepositoryContentSynchronisationObservation.
func (in *RemoteCondaRepositoryContentSynchronisationObservation) DeepCopy() *RemoteCondaRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteCondaRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCondaRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteCondaRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCondaRepositoryContentSynchronisationParameters.
func (in *RemoteCondaRepositoryContentSynchronisationParameters) DeepCopy() *RemoteCondaRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCondaRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCondaRepositoryInitParameters) DeepCopyInto(out *RemoteCondaRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCondaRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCondaRepositoryInitParameters.
func (in *RemoteCondaRepositoryInitParameters) DeepCopy() *RemoteCondaRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCondaRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCondaRepositoryList) DeepCopyInto(out *RemoteCondaRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteCondaRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCondaRepositoryList.
func (in *RemoteCondaRepositoryList) DeepCopy() *RemoteCondaRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteCondaRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteCondaRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCondaRepositoryObservation) DeepCopyInto(out *RemoteCondaRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCondaRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCondaRepositoryObservation.
func (in *RemoteCondaRepositoryObservation) DeepCopy() *RemoteCondaRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteCondaRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCondaRepositoryParameters) DeepCopyInto(out *RemoteCondaRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCondaRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCondaRepositoryParameters.
func (in *RemoteCondaRepositoryParameters) DeepCopy() *RemoteCondaRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCondaRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCondaRepositorySpec) DeepCopyInto(out *RemoteCondaRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCondaRepositorySpec.
func (in *RemoteCondaRepositorySpec) DeepCopy() *RemoteCondaRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteCondaRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCondaRepositoryStatus) DeepCopyInto(out *RemoteCondaRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCondaRepositoryStatus.
func (in *RemoteCondaRepositoryStatus) DeepCopy() *RemoteCondaRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteCondaRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCranRepository) DeepCopyInto(out *RemoteCranRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCranRepository.
func (in *RemoteCranRepository) DeepCopy() *RemoteCranRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteCranRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteCranRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCranRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteCranRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCranRepositoryContentSynchronisationInitParameters.
func (in *RemoteCranRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteCranRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCranRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCranRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteCranRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCranRepositoryContentSynchronisationObservation.
func (in *RemoteCranRepositoryContentSynchronisationObservation) DeepCopy() *RemoteCranRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteCranRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCranRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteCranRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCranRepositoryContentSynchronisationParameters.
func (in *RemoteCranRepositoryContentSynchronisationParameters) DeepCopy() *RemoteCranRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCranRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCranRepositoryInitParameters) DeepCopyInto(out *RemoteCranRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCranRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCranRepositoryInitParameters.
func (in *RemoteCranRepositoryInitParameters) DeepCopy() *RemoteCranRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCranRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCranRepositoryList) DeepCopyInto(out *RemoteCranRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteCranRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCranRepositoryList.
func (in *RemoteCranRepositoryList) DeepCopy() *RemoteCranRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteCranRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteCranRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCranRepositoryObservation) DeepCopyInto(out *RemoteCranRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCranRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCranRepositoryObservation.
func (in *RemoteCranRepositoryObservation) DeepCopy() *RemoteCranRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteCranRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCranRepositoryParameters) DeepCopyInto(out *RemoteCranRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteCranRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCranRepositoryParameters.
func (in *RemoteCranRepositoryParameters) DeepCopy() *RemoteCranRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteCranRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCranRepositorySpec) DeepCopyInto(out *RemoteCranRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCranRepositorySpec.
func (in *RemoteCranRepositorySpec) DeepCopy() *RemoteCranRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteCranRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteCranRepositoryStatus) DeepCopyInto(out *RemoteCranRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteCranRepositoryStatus.
func (in *RemoteCranRepositoryStatus) DeepCopy() *RemoteCranRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteCranRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDebianRepository) DeepCopyInto(out *RemoteDebianRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDebianRepository.
func (in *RemoteDebianRepository) DeepCopy() *RemoteDebianRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteDebianRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteDebianRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDebianRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteDebianRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDebianRepositoryContentSynchronisationInitParameters.
func (in *RemoteDebianRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteDebianRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteDebianRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDebianRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteDebianRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDebianRepositoryContentSynchronisationObservation.
func (in *RemoteDebianRepositoryContentSynchronisationObservation) DeepCopy() *RemoteDebianRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteDebianRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDebianRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteDebianRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDebianRepositoryContentSynchronisationParameters.
func (in *RemoteDebianRepositoryContentSynchronisationParameters) DeepCopy() *RemoteDebianRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteDebianRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDebianRepositoryInitParameters) DeepCopyInto(out *RemoteDebianRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteDebianRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDebianRepositoryInitParameters.
func (in *RemoteDebianRepositoryInitParameters) DeepCopy() *RemoteDebianRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteDebianRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDebianRepositoryList) DeepCopyInto(out *RemoteDebianRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteDebianRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDebianRepositoryList.
func (in *RemoteDebianRepositoryList) DeepCopy() *RemoteDebianRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteDebianRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteDebianRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDebianRepositoryObservation) DeepCopyInto(out *RemoteDebianRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteDebianRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDebianRepositoryObservation.
func (in *RemoteDebianRepositoryObservation) DeepCopy() *RemoteDebianRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteDebianRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDebianRepositoryParameters) DeepCopyInto(out *RemoteDebianRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteDebianRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDebianRepositoryParameters.
func (in *RemoteDebianRepositoryParameters) DeepCopy() *RemoteDebianRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteDebianRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDebianRepositorySpec) DeepCopyInto(out *RemoteDebianRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDebianRepositorySpec.
func (in *RemoteDebianRepositorySpec) DeepCopy() *RemoteDebianRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteDebianRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDebianRepositoryStatus) DeepCopyInto(out *RemoteDebianRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDebianRepositoryStatus.
func (in *RemoteDebianRepositoryStatus) DeepCopy() *RemoteDebianRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteDebianRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDockerRepository) DeepCopyInto(out *RemoteDockerRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDockerRepository.
func (in *RemoteDockerRepository) DeepCopy() *RemoteDockerRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteDockerRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteDockerRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDockerRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteDockerRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDockerRepositoryContentSynchronisationInitParameters.
func (in *RemoteDockerRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteDockerRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteDockerRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDockerRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteDockerRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDockerRepositoryContentSynchronisationObservation.
func (in *RemoteDockerRepositoryContentSynchronisationObservation) DeepCopy() *RemoteDockerRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteDockerRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDockerRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteDockerRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDockerRepositoryContentSynchronisationParameters.
func (in *RemoteDockerRepositoryContentSynchronisationParameters) DeepCopy() *RemoteDockerRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteDockerRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDockerRepositoryInitParameters) DeepCopyInto(out *RemoteDockerRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BlockPushingSchema1 != nil {
		in, out := &in.BlockPushingSchema1, &out.BlockPushingSchema1
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteDockerRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDockerRepositoryInitParameters.
func (in *RemoteDockerRepositoryInitParameters) DeepCopy() *RemoteDockerRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteDockerRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDockerRepositoryList) DeepCopyInto(out *RemoteDockerRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteDockerRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDockerRepositoryList.
func (in *RemoteDockerRepositoryList) DeepCopy() *RemoteDockerRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteDockerRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteDockerRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDockerRepositoryObservation) DeepCopyInto(out *RemoteDockerRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BlockPushingSchema1 != nil {
		in, out := &in.BlockPushingSchema1, &out.BlockPushingSchema1
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteDockerRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDockerRepositoryObservation.
func (in *RemoteDockerRepositoryObservation) DeepCopy() *RemoteDockerRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteDockerRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDockerRepositoryParameters) DeepCopyInto(out *RemoteDockerRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BlockPushingSchema1 != nil {
		in, out := &in.BlockPushingSchema1, &out.BlockPushingSchema1
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteDockerRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDockerRepositoryParameters.
func (in *RemoteDockerRepositoryParameters) DeepCopy() *RemoteDockerRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteDockerRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDockerRepositorySpec) DeepCopyInto(out *RemoteDockerRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDockerRepositorySpec.
func (in *RemoteDockerRepositorySpec) DeepCopy() *RemoteDockerRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteDockerRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteDockerRepositoryStatus) DeepCopyInto(out *RemoteDockerRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteDockerRepositoryStatus.
func (in *RemoteDockerRepositoryStatus) DeepCopy() *RemoteDockerRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteDockerRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGemsRepository) DeepCopyInto(out *RemoteGemsRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGemsRepository.
func (in *RemoteGemsRepository) DeepCopy() *RemoteGemsRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteGemsRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteGemsRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGemsRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteGemsRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGemsRepositoryContentSynchronisationInitParameters.
func (in *RemoteGemsRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteGemsRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGemsRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGemsRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteGemsRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGemsRepositoryContentSynchronisationObservation.
func (in *RemoteGemsRepositoryContentSynchronisationObservation) DeepCopy() *RemoteGemsRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteGemsRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGemsRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteGemsRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGemsRepositoryContentSynchronisationParameters.
func (in *RemoteGemsRepositoryContentSynchronisationParameters) DeepCopy() *RemoteGemsRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGemsRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGemsRepositoryInitParameters) DeepCopyInto(out *RemoteGemsRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGemsRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGemsRepositoryInitParameters.
func (in *RemoteGemsRepositoryInitParameters) DeepCopy() *RemoteGemsRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGemsRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGemsRepositoryList) DeepCopyInto(out *RemoteGemsRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteGemsRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGemsRepositoryList.
func (in *RemoteGemsRepositoryList) DeepCopy() *RemoteGemsRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteGemsRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteGemsRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGemsRepositoryObservation) DeepCopyInto(out *RemoteGemsRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGemsRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGemsRepositoryObservation.
func (in *RemoteGemsRepositoryObservation) DeepCopy() *RemoteGemsRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteGemsRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGemsRepositoryParameters) DeepCopyInto(out *RemoteGemsRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGemsRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGemsRepositoryParameters.
func (in *RemoteGemsRepositoryParameters) DeepCopy() *RemoteGemsRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGemsRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGemsRepositorySpec) DeepCopyInto(out *RemoteGemsRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGemsRepositorySpec.
func (in *RemoteGemsRepositorySpec) DeepCopy() *RemoteGemsRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteGemsRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGemsRepositoryStatus) DeepCopyInto(out *RemoteGemsRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGemsRepositoryStatus.
func (in *RemoteGemsRepositoryStatus) DeepCopy() *RemoteGemsRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteGemsRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGenericRepository) DeepCopyInto(out *RemoteGenericRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGenericRepository.
func (in *RemoteGenericRepository) DeepCopy() *RemoteGenericRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteGenericRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteGenericRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGenericRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteGenericRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGenericRepositoryContentSynchronisationInitParameters.
func (in *RemoteGenericRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteGenericRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGenericRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGenericRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteGenericRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGenericRepositoryContentSynchronisationObservation.
func (in *RemoteGenericRepositoryContentSynchronisationObservation) DeepCopy() *RemoteGenericRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteGenericRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGenericRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteGenericRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGenericRepositoryContentSynchronisationParameters.
func (in *RemoteGenericRepositoryContentSynchronisationParameters) DeepCopy() *RemoteGenericRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGenericRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGenericRepositoryInitParameters) DeepCopyInto(out *RemoteGenericRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGenericRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGenericRepositoryInitParameters.
func (in *RemoteGenericRepositoryInitParameters) DeepCopy() *RemoteGenericRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGenericRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGenericRepositoryList) DeepCopyInto(out *RemoteGenericRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteGenericRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGenericRepositoryList.
func (in *RemoteGenericRepositoryList) DeepCopy() *RemoteGenericRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteGenericRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteGenericRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGenericRepositoryObservation) DeepCopyInto(out *RemoteGenericRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGenericRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGenericRepositoryObservation.
func (in *RemoteGenericRepositoryObservation) DeepCopy() *RemoteGenericRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteGenericRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGenericRepositoryParameters) DeepCopyInto(out *RemoteGenericRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGenericRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGenericRepositoryParameters.
func (in *RemoteGenericRepositoryParameters) DeepCopy() *RemoteGenericRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGenericRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGenericRepositorySpec) DeepCopyInto(out *RemoteGenericRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGenericRepositorySpec.
func (in *RemoteGenericRepositorySpec) DeepCopy() *RemoteGenericRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteGenericRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGenericRepositoryStatus) DeepCopyInto(out *RemoteGenericRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGenericRepositoryStatus.
func (in *RemoteGenericRepositoryStatus) DeepCopy() *RemoteGenericRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteGenericRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGitLFSRepository) DeepCopyInto(out *RemoteGitLFSRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGitLFSRepository.
func (in *RemoteGitLFSRepository) DeepCopy() *RemoteGitLFSRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteGitLFSRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteGitLFSRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGitLFSRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteGitLFSRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGitLFSRepositoryContentSynchronisationInitParameters.
func (in *RemoteGitLFSRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteGitLFSRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGitLFSRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGitLFSRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteGitLFSRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGitLFSRepositoryContentSynchronisationObservation.
func (in *RemoteGitLFSRepositoryContentSynchronisationObservation) DeepCopy() *RemoteGitLFSRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteGitLFSRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGitLFSRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteGitLFSRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGitLFSRepositoryContentSynchronisationParameters.
func (in *RemoteGitLFSRepositoryContentSynchronisationParameters) DeepCopy() *RemoteGitLFSRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGitLFSRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGitLFSRepositoryInitParameters) DeepCopyInto(out *RemoteGitLFSRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGitLFSRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGitLFSRepositoryInitParameters.
func (in *RemoteGitLFSRepositoryInitParameters) DeepCopy() *RemoteGitLFSRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGitLFSRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGitLFSRepositoryList) DeepCopyInto(out *RemoteGitLFSRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteGitLFSRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGitLFSRepositoryList.
func (in *RemoteGitLFSRepositoryList) DeepCopy() *RemoteGitLFSRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteGitLFSRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteGitLFSRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGitLFSRepositoryObservation) DeepCopyInto(out *RemoteGitLFSRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGitLFSRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGitLFSRepositoryObservation.
func (in *RemoteGitLFSRepositoryObservation) DeepCopy() *RemoteGitLFSRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteGitLFSRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGitLFSRepositoryParameters) DeepCopyInto(out *RemoteGitLFSRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGitLFSRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGitLFSRepositoryParameters.
func (in *RemoteGitLFSRepositoryParameters) DeepCopy() *RemoteGitLFSRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGitLFSRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGitLFSRepositorySpec) DeepCopyInto(out *RemoteGitLFSRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGitLFSRepositorySpec.
func (in *RemoteGitLFSRepositorySpec) DeepCopy() *RemoteGitLFSRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteGitLFSRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGitLFSRepositoryStatus) DeepCopyInto(out *RemoteGitLFSRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGitLFSRepositoryStatus.
func (in *RemoteGitLFSRepositoryStatus) DeepCopy() *RemoteGitLFSRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteGitLFSRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGoRepository) DeepCopyInto(out *RemoteGoRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGoRepository.
func (in *RemoteGoRepository) DeepCopy() *RemoteGoRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteGoRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteGoRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGoRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteGoRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGoRepositoryContentSynchronisationInitParameters.
func (in *RemoteGoRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteGoRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGoRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGoRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteGoRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGoRepositoryContentSynchronisationObservation.
func (in *RemoteGoRepositoryContentSynchronisationObservation) DeepCopy() *RemoteGoRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteGoRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGoRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteGoRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGoRepositoryContentSynchronisationParameters.
func (in *RemoteGoRepositoryContentSynchronisationParameters) DeepCopy() *RemoteGoRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGoRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGoRepositoryInitParameters) DeepCopyInto(out *RemoteGoRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGoRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGoRepositoryInitParameters.
func (in *RemoteGoRepositoryInitParameters) DeepCopy() *RemoteGoRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGoRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGoRepositoryList) DeepCopyInto(out *RemoteGoRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteGoRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGoRepositoryList.
func (in *RemoteGoRepositoryList) DeepCopy() *RemoteGoRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteGoRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteGoRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGoRepositoryObservation) DeepCopyInto(out *RemoteGoRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGoRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGoRepositoryObservation.
func (in *RemoteGoRepositoryObservation) DeepCopy() *RemoteGoRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteGoRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGoRepositoryParameters) DeepCopyInto(out *RemoteGoRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGoRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGoRepositoryParameters.
func (in *RemoteGoRepositoryParameters) DeepCopy() *RemoteGoRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGoRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGoRepositorySpec) DeepCopyInto(out *RemoteGoRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGoRepositorySpec.
func (in *RemoteGoRepositorySpec) DeepCopy() *RemoteGoRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteGoRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGoRepositoryStatus) DeepCopyInto(out *RemoteGoRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGoRepositoryStatus.
func (in *RemoteGoRepositoryStatus) DeepCopy() *RemoteGoRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteGoRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGradleRepository) DeepCopyInto(out *RemoteGradleRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGradleRepository.
func (in *RemoteGradleRepository) DeepCopy() *RemoteGradleRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteGradleRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteGradleRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGradleRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteGradleRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGradleRepositoryContentSynchronisationInitParameters.
func (in *RemoteGradleRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteGradleRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGradleRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGradleRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteGradleRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGradleRepositoryContentSynchronisationObservation.
func (in *RemoteGradleRepositoryContentSynchronisationObservation) DeepCopy() *RemoteGradleRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteGradleRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGradleRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteGradleRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGradleRepositoryContentSynchronisationParameters.
func (in *RemoteGradleRepositoryContentSynchronisationParameters) DeepCopy() *RemoteGradleRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGradleRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGradleRepositoryInitParameters) DeepCopyInto(out *RemoteGradleRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGradleRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGradleRepositoryInitParameters.
func (in *RemoteGradleRepositoryInitParameters) DeepCopy() *RemoteGradleRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGradleRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGradleRepositoryList) DeepCopyInto(out *RemoteGradleRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteGradleRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGradleRepositoryList.
func (in *RemoteGradleRepositoryList) DeepCopy() *RemoteGradleRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteGradleRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteGradleRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGradleRepositoryObservation) DeepCopyInto(out *RemoteGradleRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGradleRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGradleRepositoryObservation.
func (in *RemoteGradleRepositoryObservation) DeepCopy() *RemoteGradleRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteGradleRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGradleRepositoryParameters) DeepCopyInto(out *RemoteGradleRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteGradleRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGradleRepositoryParameters.
func (in *RemoteGradleRepositoryParameters) DeepCopy() *RemoteGradleRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteGradleRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGradleRepositorySpec) DeepCopyInto(out *RemoteGradleRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGradleRepositorySpec.
func (in *RemoteGradleRepositorySpec) DeepCopy() *RemoteGradleRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteGradleRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteGradleRepositoryStatus) DeepCopyInto(out *RemoteGradleRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteGradleRepositoryStatus.
func (in *RemoteGradleRepositoryStatus) DeepCopy() *RemoteGradleRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteGradleRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmOCIRepository) DeepCopyInto(out *RemoteHelmOCIRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmOCIRepository.
func (in *RemoteHelmOCIRepository) DeepCopy() *RemoteHelmOCIRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmOCIRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteHelmOCIRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmOCIRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteHelmOCIRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmOCIRepositoryContentSynchronisationInitParameters.
func (in *RemoteHelmOCIRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteHelmOCIRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmOCIRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmOCIRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteHelmOCIRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmOCIRepositoryContentSynchronisationObservation.
func (in *RemoteHelmOCIRepositoryContentSynchronisationObservation) DeepCopy() *RemoteHelmOCIRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmOCIRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmOCIRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteHelmOCIRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmOCIRepositoryContentSynchronisationParameters.
func (in *RemoteHelmOCIRepositoryContentSynchronisationParameters) DeepCopy() *RemoteHelmOCIRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmOCIRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmOCIRepositoryInitParameters) DeepCopyInto(out *RemoteHelmOCIRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteHelmOCIRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmOCIRepositoryInitParameters.
func (in *RemoteHelmOCIRepositoryInitParameters) DeepCopy() *RemoteHelmOCIRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmOCIRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmOCIRepositoryList) DeepCopyInto(out *RemoteHelmOCIRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteHelmOCIRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmOCIRepositoryList.
func (in *RemoteHelmOCIRepositoryList) DeepCopy() *RemoteHelmOCIRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmOCIRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteHelmOCIRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmOCIRepositoryObservation) DeepCopyInto(out *RemoteHelmOCIRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteHelmOCIRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmOCIRepositoryObservation.
func (in *RemoteHelmOCIRepositoryObservation) DeepCopy() *RemoteHelmOCIRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmOCIRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmOCIRepositoryParameters) DeepCopyInto(out *RemoteHelmOCIRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteHelmOCIRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmOCIRepositoryParameters.
func (in *RemoteHelmOCIRepositoryParameters) DeepCopy() *RemoteHelmOCIRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmOCIRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmOCIRepositorySpec) DeepCopyInto(out *RemoteHelmOCIRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmOCIRepositorySpec.
func (in *RemoteHelmOCIRepositorySpec) DeepCopy() *RemoteHelmOCIRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmOCIRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmOCIRepositoryStatus) DeepCopyInto(out *RemoteHelmOCIRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmOCIRepositoryStatus.
func (in *RemoteHelmOCIRepositoryStatus) DeepCopy() *RemoteHelmOCIRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmOCIRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmRepository) DeepCopyInto(out *RemoteHelmRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmRepository.
func (in *RemoteHelmRepository) DeepCopy() *RemoteHelmRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteHelmRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteHelmRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmRepositoryContentSynchronisationInitParameters.
func (in *RemoteHelmRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteHelmRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteHelmRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmRepositoryContentSynchronisationObservation.
func (in *RemoteHelmRepositoryContentSynchronisationObservation) DeepCopy() *RemoteHelmRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteHelmRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmRepositoryContentSynchronisationParameters.
func (in *RemoteHelmRepositoryContentSynchronisationParameters) DeepCopy() *RemoteHelmRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmRepositoryInitParameters) DeepCopyInto(out *RemoteHelmRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteHelmRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.HelmChartsBaseURL != nil {
		in, out := &in.HelmChartsBaseURL, &out.HelmChartsBaseURL
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmRepositoryInitParameters.
func (in *RemoteHelmRepositoryInitParameters) DeepCopy() *RemoteHelmRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmRepositoryList) DeepCopyInto(out *RemoteHelmRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteHelmRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmRepositoryList.
func (in *RemoteHelmRepositoryList) DeepCopy() *RemoteHelmRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteHelmRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmRepositoryObservation) DeepCopyInto(out *RemoteHelmRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteHelmRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.HelmChartsBaseURL != nil {
		in, out := &in.HelmChartsBaseURL, &out.HelmChartsBaseURL
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmRepositoryObservation.
func (in *RemoteHelmRepositoryObservation) DeepCopy() *RemoteHelmRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmRepositoryParameters) DeepCopyInto(out *RemoteHelmRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteHelmRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.HelmChartsBaseURL != nil {
		in, out := &in.HelmChartsBaseURL, &out.HelmChartsBaseURL
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmRepositoryParameters.
func (in *RemoteHelmRepositoryParameters) DeepCopy() *RemoteHelmRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmRepositorySpec) DeepCopyInto(out *RemoteHelmRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmRepositorySpec.
func (in *RemoteHelmRepositorySpec) DeepCopy() *RemoteHelmRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHelmRepositoryStatus) DeepCopyInto(out *RemoteHelmRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHelmRepositoryStatus.
func (in *RemoteHelmRepositoryStatus) DeepCopy() *RemoteHelmRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteHelmRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHuggingfacemlRepository) DeepCopyInto(out *RemoteHuggingfacemlRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHuggingfacemlRepository.
func (in *RemoteHuggingfacemlRepository) DeepCopy() *RemoteHuggingfacemlRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteHuggingfacemlRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteHuggingfacemlRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHuggingfacemlRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteHuggingfacemlRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHuggingfacemlRepositoryContentSynchronisationInitParameters.
func (in *RemoteHuggingfacemlRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteHuggingfacemlRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHuggingfacemlRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHuggingfacemlRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteHuggingfacemlRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHuggingfacemlRepositoryContentSynchronisationObservation.
func (in *RemoteHuggingfacemlRepositoryContentSynchronisationObservation) DeepCopy() *RemoteHuggingfacemlRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteHuggingfacemlRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHuggingfacemlRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteHuggingfacemlRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHuggingfacemlRepositoryContentSynchronisationParameters.
func (in *RemoteHuggingfacemlRepositoryContentSynchronisationParameters) DeepCopy() *RemoteHuggingfacemlRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHuggingfacemlRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHuggingfacemlRepositoryInitParameters) DeepCopyInto(out *RemoteHuggingfacemlRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteHuggingfacemlRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHuggingfacemlRepositoryInitParameters.
func (in *RemoteHuggingfacemlRepositoryInitParameters) DeepCopy() *RemoteHuggingfacemlRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHuggingfacemlRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHuggingfacemlRepositoryList) DeepCopyInto(out *RemoteHuggingfacemlRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteHuggingfacemlRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHuggingfacemlRepositoryList.
func (in *RemoteHuggingfacemlRepositoryList) DeepCopy() *RemoteHuggingfacemlRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteHuggingfacemlRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteHuggingfacemlRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHuggingfacemlRepositoryObservation) DeepCopyInto(out *RemoteHuggingfacemlRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteHuggingfacemlRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHuggingfacemlRepositoryObservation.
func (in *RemoteHuggingfacemlRepositoryObservation) DeepCopy() *RemoteHuggingfacemlRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteHuggingfacemlRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHuggingfacemlRepositoryParameters) DeepCopyInto(out *RemoteHuggingfacemlRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteHuggingfacemlRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHuggingfacemlRepositoryParameters.
func (in *RemoteHuggingfacemlRepositoryParameters) DeepCopy() *RemoteHuggingfacemlRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteHuggingfacemlRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHuggingfacemlRepositorySpec) DeepCopyInto(out *RemoteHuggingfacemlRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHuggingfacemlRepositorySpec.
func (in *RemoteHuggingfacemlRepositorySpec) DeepCopy() *RemoteHuggingfacemlRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteHuggingfacemlRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteHuggingfacemlRepositoryStatus) DeepCopyInto(out *RemoteHuggingfacemlRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteHuggingfacemlRepositoryStatus.
func (in *RemoteHuggingfacemlRepositoryStatus) DeepCopy() *RemoteHuggingfacemlRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteHuggingfacemlRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteIvyRepository) DeepCopyInto(out *RemoteIvyRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteIvyRepository.
func (in *RemoteIvyRepository) DeepCopy() *RemoteIvyRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteIvyRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteIvyRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteIvyRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteIvyRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteIvyRepositoryContentSynchronisationInitParameters.
func (in *RemoteIvyRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteIvyRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteIvyRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteIvyRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteIvyRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteIvyRepositoryContentSynchronisationObservation.
func (in *RemoteIvyRepositoryContentSynchronisationObservation) DeepCopy() *RemoteIvyRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteIvyRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteIvyRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteIvyRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteIvyRepositoryContentSynchronisationParameters.
func (in *RemoteIvyRepositoryContentSynchronisationParameters) DeepCopy() *RemoteIvyRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteIvyRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteIvyRepositoryInitParameters) DeepCopyInto(out *RemoteIvyRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteIvyRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteIvyRepositoryInitParameters.
func (in *RemoteIvyRepositoryInitParameters) DeepCopy() *RemoteIvyRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteIvyRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteIvyRepositoryList) DeepCopyInto(out *RemoteIvyRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteIvyRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteIvyRepositoryList.
func (in *RemoteIvyRepositoryList) DeepCopy() *RemoteIvyRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteIvyRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteIvyRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteIvyRepositoryObservation) DeepCopyInto(out *RemoteIvyRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteIvyRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteIvyRepositoryObservation.
func (in *RemoteIvyRepositoryObservation) DeepCopy() *RemoteIvyRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteIvyRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteIvyRepositoryParameters) DeepCopyInto(out *RemoteIvyRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteIvyRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteIvyRepositoryParameters.
func (in *RemoteIvyRepositoryParameters) DeepCopy() *RemoteIvyRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteIvyRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteIvyRepositorySpec) DeepCopyInto(out *RemoteIvyRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteIvyRepositorySpec.
func (in *RemoteIvyRepositorySpec) DeepCopy() *RemoteIvyRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteIvyRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteIvyRepositoryStatus) DeepCopyInto(out *RemoteIvyRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteIvyRepositoryStatus.
func (in *RemoteIvyRepositoryStatus) DeepCopy() *RemoteIvyRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteIvyRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteMavenRepository) DeepCopyInto(out *RemoteMavenRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteMavenRepository.
func (in *RemoteMavenRepository) DeepCopy() *RemoteMavenRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteMavenRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteMavenRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteMavenRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteMavenRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteMavenRepositoryContentSynchronisationInitParameters.
func (in *RemoteMavenRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteMavenRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteMavenRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteMavenRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteMavenRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteMavenRepositoryContentSynchronisationObservation.
func (in *RemoteMavenRepositoryContentSynchronisationObservation) DeepCopy() *RemoteMavenRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteMavenRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteMavenRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteMavenRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteMavenRepositoryContentSynchronisationParameters.
func (in *RemoteMavenRepositoryContentSynchronisationParameters) DeepCopy() *RemoteMavenRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteMavenRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteMavenRepositoryInitParameters) DeepCopyInto(out *RemoteMavenRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteMavenRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteMavenRepositoryInitParameters.
func (in *RemoteMavenRepositoryInitParameters) DeepCopy() *RemoteMavenRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteMavenRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteMavenRepositoryList) DeepCopyInto(out *RemoteMavenRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteMavenRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteMavenRepositoryList.
func (in *RemoteMavenRepositoryList) DeepCopy() *RemoteMavenRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteMavenRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteMavenRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteMavenRepositoryObservation) DeepCopyInto(out *RemoteMavenRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteMavenRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteMavenRepositoryObservation.
func (in *RemoteMavenRepositoryObservation) DeepCopy() *RemoteMavenRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteMavenRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteMavenRepositoryParameters) DeepCopyInto(out *RemoteMavenRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteMavenRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteMavenRepositoryParameters.
func (in *RemoteMavenRepositoryParameters) DeepCopy() *RemoteMavenRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteMavenRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteMavenRepositorySpec) DeepCopyInto(out *RemoteMavenRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteMavenRepositorySpec.
func (in *RemoteMavenRepositorySpec) DeepCopy() *RemoteMavenRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteMavenRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteMavenRepositoryStatus) DeepCopyInto(out *RemoteMavenRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteMavenRepositoryStatus.
func (in *RemoteMavenRepositoryStatus) DeepCopy() *RemoteMavenRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteMavenRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNpmRepository) DeepCopyInto(out *RemoteNpmRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNpmRepository.
func (in *RemoteNpmRepository) DeepCopy() *RemoteNpmRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteNpmRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteNpmRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNpmRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteNpmRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNpmRepositoryContentSynchronisationInitParameters.
func (in *RemoteNpmRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteNpmRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteNpmRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNpmRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteNpmRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNpmRepositoryContentSynchronisationObservation.
func (in *RemoteNpmRepositoryContentSynchronisationObservation) DeepCopy() *RemoteNpmRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteNpmRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNpmRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteNpmRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNpmRepositoryContentSynchronisationParameters.
func (in *RemoteNpmRepositoryContentSynchronisationParameters) DeepCopy() *RemoteNpmRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteNpmRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNpmRepositoryInitParameters) DeepCopyInto(out *RemoteNpmRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteNpmRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNpmRepositoryInitParameters.
func (in *RemoteNpmRepositoryInitParameters) DeepCopy() *RemoteNpmRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteNpmRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNpmRepositoryList) DeepCopyInto(out *RemoteNpmRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteNpmRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNpmRepositoryList.
func (in *RemoteNpmRepositoryList) DeepCopy() *RemoteNpmRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteNpmRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteNpmRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNpmRepositoryObservation) DeepCopyInto(out *RemoteNpmRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteNpmRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNpmRepositoryObservation.
func (in *RemoteNpmRepositoryObservation) DeepCopy() *RemoteNpmRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteNpmRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNpmRepositoryParameters) DeepCopyInto(out *RemoteNpmRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteNpmRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNpmRepositoryParameters.
func (in *RemoteNpmRepositoryParameters) DeepCopy() *RemoteNpmRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteNpmRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNpmRepositorySpec) DeepCopyInto(out *RemoteNpmRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNpmRepositorySpec.
func (in *RemoteNpmRepositorySpec) DeepCopy() *RemoteNpmRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteNpmRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNpmRepositoryStatus) DeepCopyInto(out *RemoteNpmRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNpmRepositoryStatus.
func (in *RemoteNpmRepositoryStatus) DeepCopy() *RemoteNpmRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteNpmRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNugetRepository) DeepCopyInto(out *RemoteNugetRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNugetRepository.
func (in *RemoteNugetRepository) DeepCopy() *RemoteNugetRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteNugetRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteNugetRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNugetRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteNugetRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNugetRepositoryContentSynchronisationInitParameters.
func (in *RemoteNugetRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteNugetRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteNugetRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNugetRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteNugetRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNugetRepositoryContentSynchronisationObservation.
func (in *RemoteNugetRepositoryContentSynchronisationObservation) DeepCopy() *RemoteNugetRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteNugetRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNugetRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteNugetRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNugetRepositoryContentSynchronisationParameters.
func (in *RemoteNugetRepositoryContentSynchronisationParameters) DeepCopy() *RemoteNugetRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteNugetRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNugetRepositoryInitParameters) DeepCopyInto(out *RemoteNugetRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteNugetRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadContextPath != nil {
		in, out := &in.DownloadContextPath, &out.DownloadContextPath
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FeedContextPath != nil {
		in, out := &in.FeedContextPath, &out.FeedContextPath
		*out = new(string)
		**out = **in
	}
	if in.ForceNugetAuthentication != nil {
		in, out := &in.ForceNugetAuthentication, &out.ForceNugetAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SymbolServerURL != nil {
		in, out := &in.SymbolServerURL, &out.SymbolServerURL
		*out = new(string)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.V3FeedURL != nil {
		in, out := &in.V3FeedURL, &out.V3FeedURL
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNugetRepositoryInitParameters.
func (in *RemoteNugetRepositoryInitParameters) DeepCopy() *RemoteNugetRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteNugetRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNugetRepositoryList) DeepCopyInto(out *RemoteNugetRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteNugetRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNugetRepositoryList.
func (in *RemoteNugetRepositoryList) DeepCopy() *RemoteNugetRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteNugetRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteNugetRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNugetRepositoryObservation) DeepCopyInto(out *RemoteNugetRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteNugetRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadContextPath != nil {
		in, out := &in.DownloadContextPath, &out.DownloadContextPath
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FeedContextPath != nil {
		in, out := &in.FeedContextPath, &out.FeedContextPath
		*out = new(string)
		**out = **in
	}
	if in.ForceNugetAuthentication != nil {
		in, out := &in.ForceNugetAuthentication, &out.ForceNugetAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SymbolServerURL != nil {
		in, out := &in.SymbolServerURL, &out.SymbolServerURL
		*out = new(string)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.V3FeedURL != nil {
		in, out := &in.V3FeedURL, &out.V3FeedURL
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNugetRepositoryObservation.
func (in *RemoteNugetRepositoryObservation) DeepCopy() *RemoteNugetRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteNugetRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNugetRepositoryParameters) DeepCopyInto(out *RemoteNugetRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteNugetRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadContextPath != nil {
		in, out := &in.DownloadContextPath, &out.DownloadContextPath
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FeedContextPath != nil {
		in, out := &in.FeedContextPath, &out.FeedContextPath
		*out = new(string)
		**out = **in
	}
	if in.ForceNugetAuthentication != nil {
		in, out := &in.ForceNugetAuthentication, &out.ForceNugetAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SymbolServerURL != nil {
		in, out := &in.SymbolServerURL, &out.SymbolServerURL
		*out = new(string)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.V3FeedURL != nil {
		in, out := &in.V3FeedURL, &out.V3FeedURL
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNugetRepositoryParameters.
func (in *RemoteNugetRepositoryParameters) DeepCopy() *RemoteNugetRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteNugetRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNugetRepositorySpec) DeepCopyInto(out *RemoteNugetRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNugetRepositorySpec.
func (in *RemoteNugetRepositorySpec) DeepCopy() *RemoteNugetRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteNugetRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteNugetRepositoryStatus) DeepCopyInto(out *RemoteNugetRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteNugetRepositoryStatus.
func (in *RemoteNugetRepositoryStatus) DeepCopy() *RemoteNugetRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteNugetRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOCIRepository) DeepCopyInto(out *RemoteOCIRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOCIRepository.
func (in *RemoteOCIRepository) DeepCopy() *RemoteOCIRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteOCIRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteOCIRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOCIRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteOCIRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOCIRepositoryContentSynchronisationInitParameters.
func (in *RemoteOCIRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteOCIRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteOCIRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOCIRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteOCIRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOCIRepositoryContentSynchronisationObservation.
func (in *RemoteOCIRepositoryContentSynchronisationObservation) DeepCopy() *RemoteOCIRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteOCIRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOCIRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteOCIRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOCIRepositoryContentSynchronisationParameters.
func (in *RemoteOCIRepositoryContentSynchronisationParameters) DeepCopy() *RemoteOCIRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteOCIRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOCIRepositoryInitParameters) DeepCopyInto(out *RemoteOCIRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteOCIRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOCIRepositoryInitParameters.
func (in *RemoteOCIRepositoryInitParameters) DeepCopy() *RemoteOCIRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteOCIRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOCIRepositoryList) DeepCopyInto(out *RemoteOCIRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteOCIRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOCIRepositoryList.
func (in *RemoteOCIRepositoryList) DeepCopy() *RemoteOCIRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteOCIRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteOCIRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOCIRepositoryObservation) DeepCopyInto(out *RemoteOCIRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteOCIRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOCIRepositoryObservation.
func (in *RemoteOCIRepositoryObservation) DeepCopy() *RemoteOCIRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteOCIRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOCIRepositoryParameters) DeepCopyInto(out *RemoteOCIRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteOCIRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOCIRepositoryParameters.
func (in *RemoteOCIRepositoryParameters) DeepCopy() *RemoteOCIRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteOCIRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOCIRepositorySpec) DeepCopyInto(out *RemoteOCIRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOCIRepositorySpec.
func (in *RemoteOCIRepositorySpec) DeepCopy() *RemoteOCIRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteOCIRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOCIRepositoryStatus) DeepCopyInto(out *RemoteOCIRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOCIRepositoryStatus.
func (in *RemoteOCIRepositoryStatus) DeepCopy() *RemoteOCIRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteOCIRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOpkgRepository) DeepCopyInto(out *RemoteOpkgRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOpkgRepository.
func (in *RemoteOpkgRepository) DeepCopy() *RemoteOpkgRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteOpkgRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteOpkgRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOpkgRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteOpkgRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOpkgRepositoryContentSynchronisationInitParameters.
func (in *RemoteOpkgRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteOpkgRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteOpkgRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOpkgRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteOpkgRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOpkgRepositoryContentSynchronisationObservation.
func (in *RemoteOpkgRepositoryContentSynchronisationObservation) DeepCopy() *RemoteOpkgRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteOpkgRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOpkgRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteOpkgRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOpkgRepositoryContentSynchronisationParameters.
func (in *RemoteOpkgRepositoryContentSynchronisationParameters) DeepCopy() *RemoteOpkgRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteOpkgRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOpkgRepositoryInitParameters) DeepCopyInto(out *RemoteOpkgRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteOpkgRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOpkgRepositoryInitParameters.
func (in *RemoteOpkgRepositoryInitParameters) DeepCopy() *RemoteOpkgRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteOpkgRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOpkgRepositoryList) DeepCopyInto(out *RemoteOpkgRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteOpkgRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOpkgRepositoryList.
func (in *RemoteOpkgRepositoryList) DeepCopy() *RemoteOpkgRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteOpkgRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteOpkgRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOpkgRepositoryObservation) DeepCopyInto(out *RemoteOpkgRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteOpkgRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOpkgRepositoryObservation.
func (in *RemoteOpkgRepositoryObservation) DeepCopy() *RemoteOpkgRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteOpkgRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOpkgRepositoryParameters) DeepCopyInto(out *RemoteOpkgRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteOpkgRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOpkgRepositoryParameters.
func (in *RemoteOpkgRepositoryParameters) DeepCopy() *RemoteOpkgRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteOpkgRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOpkgRepositorySpec) DeepCopyInto(out *RemoteOpkgRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOpkgRepositorySpec.
func (in *RemoteOpkgRepositorySpec) DeepCopy() *RemoteOpkgRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteOpkgRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteOpkgRepositoryStatus) DeepCopyInto(out *RemoteOpkgRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteOpkgRepositoryStatus.
func (in *RemoteOpkgRepositoryStatus) DeepCopy() *RemoteOpkgRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteOpkgRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteP2Repository) DeepCopyInto(out *RemoteP2Repository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteP2Repository.
func (in *RemoteP2Repository) DeepCopy() *RemoteP2Repository {
	if in == nil {
		return nil
	}
	out := new(RemoteP2Repository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteP2Repository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteP2RepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteP2RepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteP2RepositoryContentSynchronisationInitParameters.
func (in *RemoteP2RepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteP2RepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteP2RepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteP2RepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteP2RepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteP2RepositoryContentSynchronisationObservation.
func (in *RemoteP2RepositoryContentSynchronisationObservation) DeepCopy() *RemoteP2RepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteP2RepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteP2RepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteP2RepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteP2RepositoryContentSynchronisationParameters.
func (in *RemoteP2RepositoryContentSynchronisationParameters) DeepCopy() *RemoteP2RepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteP2RepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteP2RepositoryInitParameters) DeepCopyInto(out *RemoteP2RepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteP2RepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteP2RepositoryInitParameters.
func (in *RemoteP2RepositoryInitParameters) DeepCopy() *RemoteP2RepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteP2RepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteP2RepositoryList) DeepCopyInto(out *RemoteP2RepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteP2Repository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteP2RepositoryList.
func (in *RemoteP2RepositoryList) DeepCopy() *RemoteP2RepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteP2RepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteP2RepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteP2RepositoryObservation) DeepCopyInto(out *RemoteP2RepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteP2RepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteP2RepositoryObservation.
func (in *RemoteP2RepositoryObservation) DeepCopy() *RemoteP2RepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteP2RepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteP2RepositoryParameters) DeepCopyInto(out *RemoteP2RepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteP2RepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteP2RepositoryParameters.
func (in *RemoteP2RepositoryParameters) DeepCopy() *RemoteP2RepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteP2RepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteP2RepositorySpec) DeepCopyInto(out *RemoteP2RepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteP2RepositorySpec.
func (in *RemoteP2RepositorySpec) DeepCopy() *RemoteP2RepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteP2RepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteP2RepositoryStatus) DeepCopyInto(out *RemoteP2RepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteP2RepositoryStatus.
func (in *RemoteP2RepositoryStatus) DeepCopy() *RemoteP2RepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteP2RepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePubRepository) DeepCopyInto(out *RemotePubRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePubRepository.
func (in *RemotePubRepository) DeepCopy() *RemotePubRepository {
	if in == nil {
		return nil
	}
	out := new(RemotePubRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemotePubRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePubRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemotePubRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePubRepositoryContentSynchronisationInitParameters.
func (in *RemotePubRepositoryContentSynchronisationInitParameters) DeepCopy() *RemotePubRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePubRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePubRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemotePubRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePubRepositoryContentSynchronisationObservation.
func (in *RemotePubRepositoryContentSynchronisationObservation) DeepCopy() *RemotePubRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemotePubRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePubRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemotePubRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePubRepositoryContentSynchronisationParameters.
func (in *RemotePubRepositoryContentSynchronisationParameters) DeepCopy() *RemotePubRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePubRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePubRepositoryInitParameters) DeepCopyInto(out *RemotePubRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemotePubRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePubRepositoryInitParameters.
func (in *RemotePubRepositoryInitParameters) DeepCopy() *RemotePubRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePubRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePubRepositoryList) DeepCopyInto(out *RemotePubRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemotePubRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePubRepositoryList.
func (in *RemotePubRepositoryList) DeepCopy() *RemotePubRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemotePubRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemotePubRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePubRepositoryObservation) DeepCopyInto(out *RemotePubRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemotePubRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePubRepositoryObservation.
func (in *RemotePubRepositoryObservation) DeepCopy() *RemotePubRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemotePubRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePubRepositoryParameters) DeepCopyInto(out *RemotePubRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemotePubRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePubRepositoryParameters.
func (in *RemotePubRepositoryParameters) DeepCopy() *RemotePubRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePubRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePubRepositorySpec) DeepCopyInto(out *RemotePubRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePubRepositorySpec.
func (in *RemotePubRepositorySpec) DeepCopy() *RemotePubRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemotePubRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePubRepositoryStatus) DeepCopyInto(out *RemotePubRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePubRepositoryStatus.
func (in *RemotePubRepositoryStatus) DeepCopy() *RemotePubRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemotePubRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePuppetRepository) DeepCopyInto(out *RemotePuppetRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePuppetRepository.
func (in *RemotePuppetRepository) DeepCopy() *RemotePuppetRepository {
	if in == nil {
		return nil
	}
	out := new(RemotePuppetRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemotePuppetRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePuppetRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemotePuppetRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePuppetRepositoryContentSynchronisationInitParameters.
func (in *RemotePuppetRepositoryContentSynchronisationInitParameters) DeepCopy() *RemotePuppetRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePuppetRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePuppetRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemotePuppetRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePuppetRepositoryContentSynchronisationObservation.
func (in *RemotePuppetRepositoryContentSynchronisationObservation) DeepCopy() *RemotePuppetRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemotePuppetRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePuppetRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemotePuppetRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePuppetRepositoryContentSynchronisationParameters.
func (in *RemotePuppetRepositoryContentSynchronisationParameters) DeepCopy() *RemotePuppetRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePuppetRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePuppetRepositoryInitParameters) DeepCopyInto(out *RemotePuppetRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemotePuppetRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePuppetRepositoryInitParameters.
func (in *RemotePuppetRepositoryInitParameters) DeepCopy() *RemotePuppetRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePuppetRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePuppetRepositoryList) DeepCopyInto(out *RemotePuppetRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemotePuppetRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePuppetRepositoryList.
func (in *RemotePuppetRepositoryList) DeepCopy() *RemotePuppetRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemotePuppetRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemotePuppetRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePuppetRepositoryObservation) DeepCopyInto(out *RemotePuppetRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemotePuppetRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePuppetRepositoryObservation.
func (in *RemotePuppetRepositoryObservation) DeepCopy() *RemotePuppetRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemotePuppetRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePuppetRepositoryParameters) DeepCopyInto(out *RemotePuppetRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemotePuppetRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePuppetRepositoryParameters.
func (in *RemotePuppetRepositoryParameters) DeepCopy() *RemotePuppetRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePuppetRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePuppetRepositorySpec) DeepCopyInto(out *RemotePuppetRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePuppetRepositorySpec.
func (in *RemotePuppetRepositorySpec) DeepCopy() *RemotePuppetRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemotePuppetRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePuppetRepositoryStatus) DeepCopyInto(out *RemotePuppetRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePuppetRepositoryStatus.
func (in *RemotePuppetRepositoryStatus) DeepCopy() *RemotePuppetRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemotePuppetRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePyPIRepository) DeepCopyInto(out *RemotePyPIRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePyPIRepository.
func (in *RemotePyPIRepository) DeepCopy() *RemotePyPIRepository {
	if in == nil {
		return nil
	}
	out := new(RemotePyPIRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemotePyPIRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePyPIRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemotePyPIRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePyPIRepositoryContentSynchronisationInitParameters.
func (in *RemotePyPIRepositoryContentSynchronisationInitParameters) DeepCopy() *RemotePyPIRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePyPIRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePyPIRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemotePyPIRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePyPIRepositoryContentSynchronisationObservation.
func (in *RemotePyPIRepositoryContentSynchronisationObservation) DeepCopy() *RemotePyPIRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemotePyPIRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePyPIRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemotePyPIRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePyPIRepositoryContentSynchronisationParameters.
func (in *RemotePyPIRepositoryContentSynchronisationParameters) DeepCopy() *RemotePyPIRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePyPIRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePyPIRepositoryInitParameters) DeepCopyInto(out *RemotePyPIRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemotePyPIRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.PypiRegistryURL != nil {
		in, out := &in.PypiRegistryURL, &out.PypiRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.PypiRepositorySuffix != nil {
		in, out := &in.PypiRepositorySuffix, &out.PypiRepositorySuffix
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePyPIRepositoryInitParameters.
func (in *RemotePyPIRepositoryInitParameters) DeepCopy() *RemotePyPIRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePyPIRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePyPIRepositoryList) DeepCopyInto(out *RemotePyPIRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemotePyPIRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePyPIRepositoryList.
func (in *RemotePyPIRepositoryList) DeepCopy() *RemotePyPIRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemotePyPIRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemotePyPIRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePyPIRepositoryObservation) DeepCopyInto(out *RemotePyPIRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemotePyPIRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.PypiRegistryURL != nil {
		in, out := &in.PypiRegistryURL, &out.PypiRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.PypiRepositorySuffix != nil {
		in, out := &in.PypiRepositorySuffix, &out.PypiRepositorySuffix
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePyPIRepositoryObservation.
func (in *RemotePyPIRepositoryObservation) DeepCopy() *RemotePyPIRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemotePyPIRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePyPIRepositoryParameters) DeepCopyInto(out *RemotePyPIRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemotePyPIRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.PypiRegistryURL != nil {
		in, out := &in.PypiRegistryURL, &out.PypiRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.PypiRepositorySuffix != nil {
		in, out := &in.PypiRepositorySuffix, &out.PypiRepositorySuffix
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePyPIRepositoryParameters.
func (in *RemotePyPIRepositoryParameters) DeepCopy() *RemotePyPIRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemotePyPIRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePyPIRepositorySpec) DeepCopyInto(out *RemotePyPIRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePyPIRepositorySpec.
func (in *RemotePyPIRepositorySpec) DeepCopy() *RemotePyPIRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemotePyPIRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemotePyPIRepositoryStatus) DeepCopyInto(out *RemotePyPIRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemotePyPIRepositoryStatus.
func (in *RemotePyPIRepositoryStatus) DeepCopy() *RemotePyPIRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemotePyPIRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteRPMRepository) DeepCopyInto(out *RemoteRPMRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRPMRepository.
func (in *RemoteRPMRepository) DeepCopy() *RemoteRPMRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteRPMRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteRPMRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteRPMRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteRPMRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRPMRepositoryContentSynchronisationInitParameters.
func (in *RemoteRPMRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteRPMRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteRPMRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteRPMRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteRPMRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRPMRepositoryContentSynchronisationObservation.
func (in *RemoteRPMRepositoryContentSynchronisationObservation) DeepCopy() *RemoteRPMRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteRPMRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteRPMRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteRPMRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRPMRepositoryContentSynchronisationParameters.
func (in *RemoteRPMRepositoryContentSynchronisationParameters) DeepCopy() *RemoteRPMRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteRPMRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteRPMRepositoryInitParameters) DeepCopyInto(out *RemoteRPMRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteRPMRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRPMRepositoryInitParameters.
func (in *RemoteRPMRepositoryInitParameters) DeepCopy() *RemoteRPMRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteRPMRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteRPMRepositoryList) DeepCopyInto(out *RemoteRPMRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteRPMRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRPMRepositoryList.
func (in *RemoteRPMRepositoryList) DeepCopy() *RemoteRPMRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteRPMRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteRPMRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteRPMRepositoryObservation) DeepCopyInto(out *RemoteRPMRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteRPMRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRPMRepositoryObservation.
func (in *RemoteRPMRepositoryObservation) DeepCopy() *RemoteRPMRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteRPMRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteRPMRepositoryParameters) DeepCopyInto(out *RemoteRPMRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteRPMRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRPMRepositoryParameters.
func (in *RemoteRPMRepositoryParameters) DeepCopy() *RemoteRPMRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteRPMRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteRPMRepositorySpec) DeepCopyInto(out *RemoteRPMRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRPMRepositorySpec.
func (in *RemoteRPMRepositorySpec) DeepCopy() *RemoteRPMRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteRPMRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteRPMRepositoryStatus) DeepCopyInto(out *RemoteRPMRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteRPMRepositoryStatus.
func (in *RemoteRPMRepositoryStatus) DeepCopy() *RemoteRPMRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteRPMRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSBTRepository) DeepCopyInto(out *RemoteSBTRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSBTRepository.
func (in *RemoteSBTRepository) DeepCopy() *RemoteSBTRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteSBTRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteSBTRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSBTRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteSBTRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSBTRepositoryContentSynchronisationInitParameters.
func (in *RemoteSBTRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteSBTRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteSBTRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSBTRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteSBTRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSBTRepositoryContentSynchronisationObservation.
func (in *RemoteSBTRepositoryContentSynchronisationObservation) DeepCopy() *RemoteSBTRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteSBTRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSBTRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteSBTRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSBTRepositoryContentSynchronisationParameters.
func (in *RemoteSBTRepositoryContentSynchronisationParameters) DeepCopy() *RemoteSBTRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteSBTRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSBTRepositoryInitParameters) DeepCopyInto(out *RemoteSBTRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteSBTRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSBTRepositoryInitParameters.
func (in *RemoteSBTRepositoryInitParameters) DeepCopy() *RemoteSBTRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteSBTRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSBTRepositoryList) DeepCopyInto(out *RemoteSBTRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteSBTRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSBTRepositoryList.
func (in *RemoteSBTRepositoryList) DeepCopy() *RemoteSBTRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteSBTRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteSBTRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSBTRepositoryObservation) DeepCopyInto(out *RemoteSBTRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteSBTRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSBTRepositoryObservation.
func (in *RemoteSBTRepositoryObservation) DeepCopy() *RemoteSBTRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteSBTRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSBTRepositoryParameters) DeepCopyInto(out *RemoteSBTRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteSBTRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSBTRepositoryParameters.
func (in *RemoteSBTRepositoryParameters) DeepCopy() *RemoteSBTRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteSBTRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSBTRepositorySpec) DeepCopyInto(out *RemoteSBTRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSBTRepositorySpec.
func (in *RemoteSBTRepositorySpec) DeepCopy() *RemoteSBTRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteSBTRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSBTRepositoryStatus) DeepCopyInto(out *RemoteSBTRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSBTRepositoryStatus.
func (in *RemoteSBTRepositoryStatus) DeepCopy() *RemoteSBTRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteSBTRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSwiftRepository) DeepCopyInto(out *RemoteSwiftRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSwiftRepository.
func (in *RemoteSwiftRepository) DeepCopy() *RemoteSwiftRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteSwiftRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteSwiftRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSwiftRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteSwiftRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSwiftRepositoryContentSynchronisationInitParameters.
func (in *RemoteSwiftRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteSwiftRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteSwiftRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSwiftRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteSwiftRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSwiftRepositoryContentSynchronisationObservation.
func (in *RemoteSwiftRepositoryContentSynchronisationObservation) DeepCopy() *RemoteSwiftRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteSwiftRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSwiftRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteSwiftRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSwiftRepositoryContentSynchronisationParameters.
func (in *RemoteSwiftRepositoryContentSynchronisationParameters) DeepCopy() *RemoteSwiftRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteSwiftRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSwiftRepositoryInitParameters) DeepCopyInto(out *RemoteSwiftRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteSwiftRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSwiftRepositoryInitParameters.
func (in *RemoteSwiftRepositoryInitParameters) DeepCopy() *RemoteSwiftRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteSwiftRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSwiftRepositoryList) DeepCopyInto(out *RemoteSwiftRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteSwiftRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSwiftRepositoryList.
func (in *RemoteSwiftRepositoryList) DeepCopy() *RemoteSwiftRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteSwiftRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteSwiftRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSwiftRepositoryObservation) DeepCopyInto(out *RemoteSwiftRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteSwiftRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSwiftRepositoryObservation.
func (in *RemoteSwiftRepositoryObservation) DeepCopy() *RemoteSwiftRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteSwiftRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSwiftRepositoryParameters) DeepCopyInto(out *RemoteSwiftRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteSwiftRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSwiftRepositoryParameters.
func (in *RemoteSwiftRepositoryParameters) DeepCopy() *RemoteSwiftRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteSwiftRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSwiftRepositorySpec) DeepCopyInto(out *RemoteSwiftRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSwiftRepositorySpec.
func (in *RemoteSwiftRepositorySpec) DeepCopy() *RemoteSwiftRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteSwiftRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteSwiftRepositoryStatus) DeepCopyInto(out *RemoteSwiftRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteSwiftRepositoryStatus.
func (in *RemoteSwiftRepositoryStatus) DeepCopy() *RemoteSwiftRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteSwiftRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteTerraformRepository) DeepCopyInto(out *RemoteTerraformRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteTerraformRepository.
func (in *RemoteTerraformRepository) DeepCopy() *RemoteTerraformRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteTerraformRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteTerraformRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteTerraformRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteTerraformRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteTerraformRepositoryContentSynchronisationInitParameters.
func (in *RemoteTerraformRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteTerraformRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteTerraformRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteTerraformRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteTerraformRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteTerraformRepositoryContentSynchronisationObservation.
func (in *RemoteTerraformRepositoryContentSynchronisationObservation) DeepCopy() *RemoteTerraformRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteTerraformRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteTerraformRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteTerraformRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteTerraformRepositoryContentSynchronisationParameters.
func (in *RemoteTerraformRepositoryContentSynchronisationParameters) DeepCopy() *RemoteTerraformRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteTerraformRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteTerraformRepositoryInitParameters) DeepCopyInto(out *RemoteTerraformRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteTerraformRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.TerraformProvidersURL != nil {
		in, out := &in.TerraformProvidersURL, &out.TerraformProvidersURL
		*out = new(string)
		**out = **in
	}
	if in.TerraformRegistryURL != nil {
		in, out := &in.TerraformRegistryURL, &out.TerraformRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteTerraformRepositoryInitParameters.
func (in *RemoteTerraformRepositoryInitParameters) DeepCopy() *RemoteTerraformRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteTerraformRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteTerraformRepositoryList) DeepCopyInto(out *RemoteTerraformRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteTerraformRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteTerraformRepositoryList.
func (in *RemoteTerraformRepositoryList) DeepCopy() *RemoteTerraformRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteTerraformRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteTerraformRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteTerraformRepositoryObservation) DeepCopyInto(out *RemoteTerraformRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteTerraformRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.TerraformProvidersURL != nil {
		in, out := &in.TerraformProvidersURL, &out.TerraformProvidersURL
		*out = new(string)
		**out = **in
	}
	if in.TerraformRegistryURL != nil {
		in, out := &in.TerraformRegistryURL, &out.TerraformRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteTerraformRepositoryObservation.
func (in *RemoteTerraformRepositoryObservation) DeepCopy() *RemoteTerraformRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteTerraformRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteTerraformRepositoryParameters) DeepCopyInto(out *RemoteTerraformRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteTerraformRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.TerraformProvidersURL != nil {
		in, out := &in.TerraformProvidersURL, &out.TerraformProvidersURL
		*out = new(string)
		**out = **in
	}
	if in.TerraformRegistryURL != nil {
		in, out := &in.TerraformRegistryURL, &out.TerraformRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteTerraformRepositoryParameters.
func (in *RemoteTerraformRepositoryParameters) DeepCopy() *RemoteTerraformRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteTerraformRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteTerraformRepositorySpec) DeepCopyInto(out *RemoteTerraformRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteTerraformRepositorySpec.
func (in *RemoteTerraformRepositorySpec) DeepCopy() *RemoteTerraformRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteTerraformRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteTerraformRepositoryStatus) DeepCopyInto(out *RemoteTerraformRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteTerraformRepositoryStatus.
func (in *RemoteTerraformRepositoryStatus) DeepCopy() *RemoteTerraformRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteTerraformRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteVCSRepository) DeepCopyInto(out *RemoteVCSRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteVCSRepository.
func (in *RemoteVCSRepository) DeepCopy() *RemoteVCSRepository {
	if in == nil {
		return nil
	}
	out := new(RemoteVCSRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteVCSRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteVCSRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RemoteVCSRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteVCSRepositoryContentSynchronisationInitParameters.
func (in *RemoteVCSRepositoryContentSynchronisationInitParameters) DeepCopy() *RemoteVCSRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteVCSRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteVCSRepositoryContentSynchronisationObservation) DeepCopyInto(out *RemoteVCSRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteVCSRepositoryContentSynchronisationObservation.
func (in *RemoteVCSRepositoryContentSynchronisationObservation) DeepCopy() *RemoteVCSRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteVCSRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteVCSRepositoryContentSynchronisationParameters) DeepCopyInto(out *RemoteVCSRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteVCSRepositoryContentSynchronisationParameters.
func (in *RemoteVCSRepositoryContentSynchronisationParameters) DeepCopy() *RemoteVCSRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteVCSRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteVCSRepositoryInitParameters) DeepCopyInto(out *RemoteVCSRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteVCSRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteVCSRepositoryInitParameters.
func (in *RemoteVCSRepositoryInitParameters) DeepCopy() *RemoteVCSRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteVCSRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteVCSRepositoryList) DeepCopyInto(out *RemoteVCSRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RemoteVCSRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteVCSRepositoryList.
func (in *RemoteVCSRepositoryList) DeepCopy() *RemoteVCSRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RemoteVCSRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RemoteVCSRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteVCSRepositoryObservation) DeepCopyInto(out *RemoteVCSRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteVCSRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteVCSRepositoryObservation.
func (in *RemoteVCSRepositoryObservation) DeepCopy() *RemoteVCSRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RemoteVCSRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteVCSRepositoryParameters) DeepCopyInto(out *RemoteVCSRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RemoteVCSRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteVCSRepositoryParameters.
func (in *RemoteVCSRepositoryParameters) DeepCopy() *RemoteVCSRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RemoteVCSRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteVCSRepositorySpec) DeepCopyInto(out *RemoteVCSRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteVCSRepositorySpec.
func (in *RemoteVCSRepositorySpec) DeepCopy() *RemoteVCSRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RemoteVCSRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RemoteVCSRepositoryStatus) DeepCopyInto(out *RemoteVCSRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RemoteVCSRepositoryStatus.
func (in *RemoteVCSRepositoryStatus) DeepCopy() *RemoteVCSRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RemoteVCSRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}
