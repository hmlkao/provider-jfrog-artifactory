//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AlpineRepository) DeepCopyInto(out *AlpineRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AlpineRepository.
func (in *AlpineRepository) DeepCopy() *AlpineRepository {
	if in == nil {
		return nil
	}
	out := new(AlpineRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AlpineRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AlpineRepositoryInitParameters) DeepCopyInto(out *AlpineRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AlpineRepositoryInitParameters.
func (in *AlpineRepositoryInitParameters) DeepCopy() *AlpineRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(AlpineRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AlpineRepositoryList) DeepCopyInto(out *AlpineRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AlpineRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AlpineRepositoryList.
func (in *AlpineRepositoryList) DeepCopy() *AlpineRepositoryList {
	if in == nil {
		return nil
	}
	out := new(AlpineRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AlpineRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AlpineRepositoryObservation) DeepCopyInto(out *AlpineRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AlpineRepositoryObservation.
func (in *AlpineRepositoryObservation) DeepCopy() *AlpineRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(AlpineRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AlpineRepositoryParameters) DeepCopyInto(out *AlpineRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AlpineRepositoryParameters.
func (in *AlpineRepositoryParameters) DeepCopy() *AlpineRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(AlpineRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AlpineRepositorySpec) DeepCopyInto(out *AlpineRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AlpineRepositorySpec.
func (in *AlpineRepositorySpec) DeepCopy() *AlpineRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(AlpineRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AlpineRepositoryStatus) DeepCopyInto(out *AlpineRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AlpineRepositoryStatus.
func (in *AlpineRepositoryStatus) DeepCopy() *AlpineRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(AlpineRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnsibleRepository) DeepCopyInto(out *AnsibleRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnsibleRepository.
func (in *AnsibleRepository) DeepCopy() *AnsibleRepository {
	if in == nil {
		return nil
	}
	out := new(AnsibleRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AnsibleRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnsibleRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *AnsibleRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnsibleRepositoryContentSynchronisationInitParameters.
func (in *AnsibleRepositoryContentSynchronisationInitParameters) DeepCopy() *AnsibleRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(AnsibleRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnsibleRepositoryContentSynchronisationObservation) DeepCopyInto(out *AnsibleRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnsibleRepositoryContentSynchronisationObservation.
func (in *AnsibleRepositoryContentSynchronisationObservation) DeepCopy() *AnsibleRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(AnsibleRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnsibleRepositoryContentSynchronisationParameters) DeepCopyInto(out *AnsibleRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnsibleRepositoryContentSynchronisationParameters.
func (in *AnsibleRepositoryContentSynchronisationParameters) DeepCopy() *AnsibleRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(AnsibleRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnsibleRepositoryInitParameters) DeepCopyInto(out *AnsibleRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]AnsibleRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnsibleRepositoryInitParameters.
func (in *AnsibleRepositoryInitParameters) DeepCopy() *AnsibleRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(AnsibleRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnsibleRepositoryList) DeepCopyInto(out *AnsibleRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]AnsibleRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnsibleRepositoryList.
func (in *AnsibleRepositoryList) DeepCopy() *AnsibleRepositoryList {
	if in == nil {
		return nil
	}
	out := new(AnsibleRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *AnsibleRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnsibleRepositoryObservation) DeepCopyInto(out *AnsibleRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]AnsibleRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnsibleRepositoryObservation.
func (in *AnsibleRepositoryObservation) DeepCopy() *AnsibleRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(AnsibleRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnsibleRepositoryParameters) DeepCopyInto(out *AnsibleRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]AnsibleRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnsibleRepositoryParameters.
func (in *AnsibleRepositoryParameters) DeepCopy() *AnsibleRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(AnsibleRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnsibleRepositorySpec) DeepCopyInto(out *AnsibleRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnsibleRepositorySpec.
func (in *AnsibleRepositorySpec) DeepCopy() *AnsibleRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(AnsibleRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AnsibleRepositoryStatus) DeepCopyInto(out *AnsibleRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AnsibleRepositoryStatus.
func (in *AnsibleRepositoryStatus) DeepCopy() *AnsibleRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(AnsibleRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BowerRepository) DeepCopyInto(out *BowerRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BowerRepository.
func (in *BowerRepository) DeepCopy() *BowerRepository {
	if in == nil {
		return nil
	}
	out := new(BowerRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *BowerRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BowerRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *BowerRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BowerRepositoryContentSynchronisationInitParameters.
func (in *BowerRepositoryContentSynchronisationInitParameters) DeepCopy() *BowerRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(BowerRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BowerRepositoryContentSynchronisationObservation) DeepCopyInto(out *BowerRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BowerRepositoryContentSynchronisationObservation.
func (in *BowerRepositoryContentSynchronisationObservation) DeepCopy() *BowerRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(BowerRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BowerRepositoryContentSynchronisationParameters) DeepCopyInto(out *BowerRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BowerRepositoryContentSynchronisationParameters.
func (in *BowerRepositoryContentSynchronisationParameters) DeepCopy() *BowerRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(BowerRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BowerRepositoryInitParameters) DeepCopyInto(out *BowerRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BowerRegistryURL != nil {
		in, out := &in.BowerRegistryURL, &out.BowerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]BowerRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BowerRepositoryInitParameters.
func (in *BowerRepositoryInitParameters) DeepCopy() *BowerRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(BowerRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BowerRepositoryList) DeepCopyInto(out *BowerRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]BowerRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BowerRepositoryList.
func (in *BowerRepositoryList) DeepCopy() *BowerRepositoryList {
	if in == nil {
		return nil
	}
	out := new(BowerRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *BowerRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BowerRepositoryObservation) DeepCopyInto(out *BowerRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BowerRegistryURL != nil {
		in, out := &in.BowerRegistryURL, &out.BowerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]BowerRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BowerRepositoryObservation.
func (in *BowerRepositoryObservation) DeepCopy() *BowerRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(BowerRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BowerRepositoryParameters) DeepCopyInto(out *BowerRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BowerRegistryURL != nil {
		in, out := &in.BowerRegistryURL, &out.BowerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]BowerRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BowerRepositoryParameters.
func (in *BowerRepositoryParameters) DeepCopy() *BowerRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(BowerRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BowerRepositorySpec) DeepCopyInto(out *BowerRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BowerRepositorySpec.
func (in *BowerRepositorySpec) DeepCopy() *BowerRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(BowerRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *BowerRepositoryStatus) DeepCopyInto(out *BowerRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new BowerRepositoryStatus.
func (in *BowerRepositoryStatus) DeepCopy() *BowerRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(BowerRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CargoRepository) DeepCopyInto(out *CargoRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CargoRepository.
func (in *CargoRepository) DeepCopy() *CargoRepository {
	if in == nil {
		return nil
	}
	out := new(CargoRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CargoRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CargoRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *CargoRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CargoRepositoryContentSynchronisationInitParameters.
func (in *CargoRepositoryContentSynchronisationInitParameters) DeepCopy() *CargoRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(CargoRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CargoRepositoryContentSynchronisationObservation) DeepCopyInto(out *CargoRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CargoRepositoryContentSynchronisationObservation.
func (in *CargoRepositoryContentSynchronisationObservation) DeepCopy() *CargoRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(CargoRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CargoRepositoryContentSynchronisationParameters) DeepCopyInto(out *CargoRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CargoRepositoryContentSynchronisationParameters.
func (in *CargoRepositoryContentSynchronisationParameters) DeepCopy() *CargoRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(CargoRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CargoRepositoryInitParameters) DeepCopyInto(out *CargoRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.AnonymousAccess != nil {
		in, out := &in.AnonymousAccess, &out.AnonymousAccess
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CargoRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableSparseIndex != nil {
		in, out := &in.EnableSparseIndex, &out.EnableSparseIndex
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.GitRegistryURL != nil {
		in, out := &in.GitRegistryURL, &out.GitRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CargoRepositoryInitParameters.
func (in *CargoRepositoryInitParameters) DeepCopy() *CargoRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(CargoRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CargoRepositoryList) DeepCopyInto(out *CargoRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]CargoRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CargoRepositoryList.
func (in *CargoRepositoryList) DeepCopy() *CargoRepositoryList {
	if in == nil {
		return nil
	}
	out := new(CargoRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CargoRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CargoRepositoryObservation) DeepCopyInto(out *CargoRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.AnonymousAccess != nil {
		in, out := &in.AnonymousAccess, &out.AnonymousAccess
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CargoRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableSparseIndex != nil {
		in, out := &in.EnableSparseIndex, &out.EnableSparseIndex
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.GitRegistryURL != nil {
		in, out := &in.GitRegistryURL, &out.GitRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CargoRepositoryObservation.
func (in *CargoRepositoryObservation) DeepCopy() *CargoRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(CargoRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CargoRepositoryParameters) DeepCopyInto(out *CargoRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.AnonymousAccess != nil {
		in, out := &in.AnonymousAccess, &out.AnonymousAccess
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CargoRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableSparseIndex != nil {
		in, out := &in.EnableSparseIndex, &out.EnableSparseIndex
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.GitRegistryURL != nil {
		in, out := &in.GitRegistryURL, &out.GitRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CargoRepositoryParameters.
func (in *CargoRepositoryParameters) DeepCopy() *CargoRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(CargoRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CargoRepositorySpec) DeepCopyInto(out *CargoRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CargoRepositorySpec.
func (in *CargoRepositorySpec) DeepCopy() *CargoRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(CargoRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CargoRepositoryStatus) DeepCopyInto(out *CargoRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CargoRepositoryStatus.
func (in *CargoRepositoryStatus) DeepCopy() *CargoRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(CargoRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChefRepository) DeepCopyInto(out *ChefRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChefRepository.
func (in *ChefRepository) DeepCopy() *ChefRepository {
	if in == nil {
		return nil
	}
	out := new(ChefRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ChefRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChefRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *ChefRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChefRepositoryContentSynchronisationInitParameters.
func (in *ChefRepositoryContentSynchronisationInitParameters) DeepCopy() *ChefRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(ChefRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChefRepositoryContentSynchronisationObservation) DeepCopyInto(out *ChefRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChefRepositoryContentSynchronisationObservation.
func (in *ChefRepositoryContentSynchronisationObservation) DeepCopy() *ChefRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(ChefRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChefRepositoryContentSynchronisationParameters) DeepCopyInto(out *ChefRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChefRepositoryContentSynchronisationParameters.
func (in *ChefRepositoryContentSynchronisationParameters) DeepCopy() *ChefRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(ChefRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChefRepositoryInitParameters) DeepCopyInto(out *ChefRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ChefRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChefRepositoryInitParameters.
func (in *ChefRepositoryInitParameters) DeepCopy() *ChefRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(ChefRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChefRepositoryList) DeepCopyInto(out *ChefRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ChefRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChefRepositoryList.
func (in *ChefRepositoryList) DeepCopy() *ChefRepositoryList {
	if in == nil {
		return nil
	}
	out := new(ChefRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ChefRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChefRepositoryObservation) DeepCopyInto(out *ChefRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ChefRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChefRepositoryObservation.
func (in *ChefRepositoryObservation) DeepCopy() *ChefRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(ChefRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChefRepositoryParameters) DeepCopyInto(out *ChefRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ChefRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChefRepositoryParameters.
func (in *ChefRepositoryParameters) DeepCopy() *ChefRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(ChefRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChefRepositorySpec) DeepCopyInto(out *ChefRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChefRepositorySpec.
func (in *ChefRepositorySpec) DeepCopy() *ChefRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(ChefRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ChefRepositoryStatus) DeepCopyInto(out *ChefRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ChefRepositoryStatus.
func (in *ChefRepositoryStatus) DeepCopy() *ChefRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(ChefRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CocoapodsRepository) DeepCopyInto(out *CocoapodsRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CocoapodsRepository.
func (in *CocoapodsRepository) DeepCopy() *CocoapodsRepository {
	if in == nil {
		return nil
	}
	out := new(CocoapodsRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CocoapodsRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CocoapodsRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *CocoapodsRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CocoapodsRepositoryContentSynchronisationInitParameters.
func (in *CocoapodsRepositoryContentSynchronisationInitParameters) DeepCopy() *CocoapodsRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(CocoapodsRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CocoapodsRepositoryContentSynchronisationObservation) DeepCopyInto(out *CocoapodsRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CocoapodsRepositoryContentSynchronisationObservation.
func (in *CocoapodsRepositoryContentSynchronisationObservation) DeepCopy() *CocoapodsRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(CocoapodsRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CocoapodsRepositoryContentSynchronisationParameters) DeepCopyInto(out *CocoapodsRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CocoapodsRepositoryContentSynchronisationParameters.
func (in *CocoapodsRepositoryContentSynchronisationParameters) DeepCopy() *CocoapodsRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(CocoapodsRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CocoapodsRepositoryInitParameters) DeepCopyInto(out *CocoapodsRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CocoapodsRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PodsSpecsRepoURL != nil {
		in, out := &in.PodsSpecsRepoURL, &out.PodsSpecsRepoURL
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CocoapodsRepositoryInitParameters.
func (in *CocoapodsRepositoryInitParameters) DeepCopy() *CocoapodsRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(CocoapodsRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CocoapodsRepositoryList) DeepCopyInto(out *CocoapodsRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]CocoapodsRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CocoapodsRepositoryList.
func (in *CocoapodsRepositoryList) DeepCopy() *CocoapodsRepositoryList {
	if in == nil {
		return nil
	}
	out := new(CocoapodsRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CocoapodsRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CocoapodsRepositoryObservation) DeepCopyInto(out *CocoapodsRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CocoapodsRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PodsSpecsRepoURL != nil {
		in, out := &in.PodsSpecsRepoURL, &out.PodsSpecsRepoURL
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CocoapodsRepositoryObservation.
func (in *CocoapodsRepositoryObservation) DeepCopy() *CocoapodsRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(CocoapodsRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CocoapodsRepositoryParameters) DeepCopyInto(out *CocoapodsRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CocoapodsRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PodsSpecsRepoURL != nil {
		in, out := &in.PodsSpecsRepoURL, &out.PodsSpecsRepoURL
		*out = new(string)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CocoapodsRepositoryParameters.
func (in *CocoapodsRepositoryParameters) DeepCopy() *CocoapodsRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(CocoapodsRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CocoapodsRepositorySpec) DeepCopyInto(out *CocoapodsRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CocoapodsRepositorySpec.
func (in *CocoapodsRepositorySpec) DeepCopy() *CocoapodsRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(CocoapodsRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CocoapodsRepositoryStatus) DeepCopyInto(out *CocoapodsRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CocoapodsRepositoryStatus.
func (in *CocoapodsRepositoryStatus) DeepCopy() *CocoapodsRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(CocoapodsRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComposerRepository) DeepCopyInto(out *ComposerRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComposerRepository.
func (in *ComposerRepository) DeepCopy() *ComposerRepository {
	if in == nil {
		return nil
	}
	out := new(ComposerRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ComposerRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComposerRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *ComposerRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComposerRepositoryContentSynchronisationInitParameters.
func (in *ComposerRepositoryContentSynchronisationInitParameters) DeepCopy() *ComposerRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(ComposerRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComposerRepositoryContentSynchronisationObservation) DeepCopyInto(out *ComposerRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComposerRepositoryContentSynchronisationObservation.
func (in *ComposerRepositoryContentSynchronisationObservation) DeepCopy() *ComposerRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(ComposerRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComposerRepositoryContentSynchronisationParameters) DeepCopyInto(out *ComposerRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComposerRepositoryContentSynchronisationParameters.
func (in *ComposerRepositoryContentSynchronisationParameters) DeepCopy() *ComposerRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(ComposerRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComposerRepositoryInitParameters) DeepCopyInto(out *ComposerRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ComposerRegistryURL != nil {
		in, out := &in.ComposerRegistryURL, &out.ComposerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ComposerRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComposerRepositoryInitParameters.
func (in *ComposerRepositoryInitParameters) DeepCopy() *ComposerRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(ComposerRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComposerRepositoryList) DeepCopyInto(out *ComposerRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ComposerRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComposerRepositoryList.
func (in *ComposerRepositoryList) DeepCopy() *ComposerRepositoryList {
	if in == nil {
		return nil
	}
	out := new(ComposerRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ComposerRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComposerRepositoryObservation) DeepCopyInto(out *ComposerRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ComposerRegistryURL != nil {
		in, out := &in.ComposerRegistryURL, &out.ComposerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ComposerRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComposerRepositoryObservation.
func (in *ComposerRepositoryObservation) DeepCopy() *ComposerRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(ComposerRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComposerRepositoryParameters) DeepCopyInto(out *ComposerRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ComposerRegistryURL != nil {
		in, out := &in.ComposerRegistryURL, &out.ComposerRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]ComposerRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComposerRepositoryParameters.
func (in *ComposerRepositoryParameters) DeepCopy() *ComposerRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(ComposerRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComposerRepositorySpec) DeepCopyInto(out *ComposerRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComposerRepositorySpec.
func (in *ComposerRepositorySpec) DeepCopy() *ComposerRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(ComposerRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ComposerRepositoryStatus) DeepCopyInto(out *ComposerRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ComposerRepositoryStatus.
func (in *ComposerRepositoryStatus) DeepCopy() *ComposerRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(ComposerRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CondaRepository) DeepCopyInto(out *CondaRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CondaRepository.
func (in *CondaRepository) DeepCopy() *CondaRepository {
	if in == nil {
		return nil
	}
	out := new(CondaRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CondaRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CondaRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *CondaRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CondaRepositoryContentSynchronisationInitParameters.
func (in *CondaRepositoryContentSynchronisationInitParameters) DeepCopy() *CondaRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(CondaRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CondaRepositoryContentSynchronisationObservation) DeepCopyInto(out *CondaRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CondaRepositoryContentSynchronisationObservation.
func (in *CondaRepositoryContentSynchronisationObservation) DeepCopy() *CondaRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(CondaRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CondaRepositoryContentSynchronisationParameters) DeepCopyInto(out *CondaRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CondaRepositoryContentSynchronisationParameters.
func (in *CondaRepositoryContentSynchronisationParameters) DeepCopy() *CondaRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(CondaRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CondaRepositoryInitParameters) DeepCopyInto(out *CondaRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CondaRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CondaRepositoryInitParameters.
func (in *CondaRepositoryInitParameters) DeepCopy() *CondaRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(CondaRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CondaRepositoryList) DeepCopyInto(out *CondaRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]CondaRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CondaRepositoryList.
func (in *CondaRepositoryList) DeepCopy() *CondaRepositoryList {
	if in == nil {
		return nil
	}
	out := new(CondaRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CondaRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CondaRepositoryObservation) DeepCopyInto(out *CondaRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CondaRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CondaRepositoryObservation.
func (in *CondaRepositoryObservation) DeepCopy() *CondaRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(CondaRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CondaRepositoryParameters) DeepCopyInto(out *CondaRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CondaRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CondaRepositoryParameters.
func (in *CondaRepositoryParameters) DeepCopy() *CondaRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(CondaRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CondaRepositorySpec) DeepCopyInto(out *CondaRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CondaRepositorySpec.
func (in *CondaRepositorySpec) DeepCopy() *CondaRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(CondaRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CondaRepositoryStatus) DeepCopyInto(out *CondaRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CondaRepositoryStatus.
func (in *CondaRepositoryStatus) DeepCopy() *CondaRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(CondaRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContentSynchronisationInitParameters) DeepCopyInto(out *ContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContentSynchronisationInitParameters.
func (in *ContentSynchronisationInitParameters) DeepCopy() *ContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(ContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContentSynchronisationObservation) DeepCopyInto(out *ContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContentSynchronisationObservation.
func (in *ContentSynchronisationObservation) DeepCopy() *ContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(ContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContentSynchronisationParameters) DeepCopyInto(out *ContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContentSynchronisationParameters.
func (in *ContentSynchronisationParameters) DeepCopy() *ContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(ContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CranRepository) DeepCopyInto(out *CranRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CranRepository.
func (in *CranRepository) DeepCopy() *CranRepository {
	if in == nil {
		return nil
	}
	out := new(CranRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CranRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CranRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *CranRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CranRepositoryContentSynchronisationInitParameters.
func (in *CranRepositoryContentSynchronisationInitParameters) DeepCopy() *CranRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(CranRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CranRepositoryContentSynchronisationObservation) DeepCopyInto(out *CranRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CranRepositoryContentSynchronisationObservation.
func (in *CranRepositoryContentSynchronisationObservation) DeepCopy() *CranRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(CranRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CranRepositoryContentSynchronisationParameters) DeepCopyInto(out *CranRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CranRepositoryContentSynchronisationParameters.
func (in *CranRepositoryContentSynchronisationParameters) DeepCopy() *CranRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(CranRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CranRepositoryInitParameters) DeepCopyInto(out *CranRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CranRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CranRepositoryInitParameters.
func (in *CranRepositoryInitParameters) DeepCopy() *CranRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(CranRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CranRepositoryList) DeepCopyInto(out *CranRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]CranRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CranRepositoryList.
func (in *CranRepositoryList) DeepCopy() *CranRepositoryList {
	if in == nil {
		return nil
	}
	out := new(CranRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CranRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CranRepositoryObservation) DeepCopyInto(out *CranRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CranRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CranRepositoryObservation.
func (in *CranRepositoryObservation) DeepCopy() *CranRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(CranRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CranRepositoryParameters) DeepCopyInto(out *CranRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]CranRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CranRepositoryParameters.
func (in *CranRepositoryParameters) DeepCopy() *CranRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(CranRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CranRepositorySpec) DeepCopyInto(out *CranRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CranRepositorySpec.
func (in *CranRepositorySpec) DeepCopy() *CranRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(CranRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CranRepositoryStatus) DeepCopyInto(out *CranRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CranRepositoryStatus.
func (in *CranRepositoryStatus) DeepCopy() *CranRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(CranRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DebianRepository) DeepCopyInto(out *DebianRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DebianRepository.
func (in *DebianRepository) DeepCopy() *DebianRepository {
	if in == nil {
		return nil
	}
	out := new(DebianRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DebianRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DebianRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *DebianRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DebianRepositoryContentSynchronisationInitParameters.
func (in *DebianRepositoryContentSynchronisationInitParameters) DeepCopy() *DebianRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(DebianRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DebianRepositoryContentSynchronisationObservation) DeepCopyInto(out *DebianRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DebianRepositoryContentSynchronisationObservation.
func (in *DebianRepositoryContentSynchronisationObservation) DeepCopy() *DebianRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(DebianRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DebianRepositoryContentSynchronisationParameters) DeepCopyInto(out *DebianRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DebianRepositoryContentSynchronisationParameters.
func (in *DebianRepositoryContentSynchronisationParameters) DeepCopy() *DebianRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(DebianRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DebianRepositoryInitParameters) DeepCopyInto(out *DebianRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]DebianRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DebianRepositoryInitParameters.
func (in *DebianRepositoryInitParameters) DeepCopy() *DebianRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(DebianRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DebianRepositoryList) DeepCopyInto(out *DebianRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DebianRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DebianRepositoryList.
func (in *DebianRepositoryList) DeepCopy() *DebianRepositoryList {
	if in == nil {
		return nil
	}
	out := new(DebianRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DebianRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DebianRepositoryObservation) DeepCopyInto(out *DebianRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]DebianRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DebianRepositoryObservation.
func (in *DebianRepositoryObservation) DeepCopy() *DebianRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(DebianRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DebianRepositoryParameters) DeepCopyInto(out *DebianRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]DebianRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DebianRepositoryParameters.
func (in *DebianRepositoryParameters) DeepCopy() *DebianRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(DebianRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DebianRepositorySpec) DeepCopyInto(out *DebianRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DebianRepositorySpec.
func (in *DebianRepositorySpec) DeepCopy() *DebianRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(DebianRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DebianRepositoryStatus) DeepCopyInto(out *DebianRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DebianRepositoryStatus.
func (in *DebianRepositoryStatus) DeepCopy() *DebianRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(DebianRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DockerRepository) DeepCopyInto(out *DockerRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepository.
func (in *DockerRepository) DeepCopy() *DockerRepository {
	if in == nil {
		return nil
	}
	out := new(DockerRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DockerRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DockerRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *DockerRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepositoryContentSynchronisationInitParameters.
func (in *DockerRepositoryContentSynchronisationInitParameters) DeepCopy() *DockerRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(DockerRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DockerRepositoryContentSynchronisationObservation) DeepCopyInto(out *DockerRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepositoryContentSynchronisationObservation.
func (in *DockerRepositoryContentSynchronisationObservation) DeepCopy() *DockerRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(DockerRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DockerRepositoryContentSynchronisationParameters) DeepCopyInto(out *DockerRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepositoryContentSynchronisationParameters.
func (in *DockerRepositoryContentSynchronisationParameters) DeepCopy() *DockerRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(DockerRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DockerRepositoryInitParameters) DeepCopyInto(out *DockerRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BlockPushingSchema1 != nil {
		in, out := &in.BlockPushingSchema1, &out.BlockPushingSchema1
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]DockerRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepositoryInitParameters.
func (in *DockerRepositoryInitParameters) DeepCopy() *DockerRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(DockerRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DockerRepositoryList) DeepCopyInto(out *DockerRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]DockerRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepositoryList.
func (in *DockerRepositoryList) DeepCopy() *DockerRepositoryList {
	if in == nil {
		return nil
	}
	out := new(DockerRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *DockerRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DockerRepositoryObservation) DeepCopyInto(out *DockerRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BlockPushingSchema1 != nil {
		in, out := &in.BlockPushingSchema1, &out.BlockPushingSchema1
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]DockerRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepositoryObservation.
func (in *DockerRepositoryObservation) DeepCopy() *DockerRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(DockerRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DockerRepositoryParameters) DeepCopyInto(out *DockerRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BlockPushingSchema1 != nil {
		in, out := &in.BlockPushingSchema1, &out.BlockPushingSchema1
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]DockerRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepositoryParameters.
func (in *DockerRepositoryParameters) DeepCopy() *DockerRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(DockerRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DockerRepositorySpec) DeepCopyInto(out *DockerRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepositorySpec.
func (in *DockerRepositorySpec) DeepCopy() *DockerRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(DockerRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DockerRepositoryStatus) DeepCopyInto(out *DockerRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DockerRepositoryStatus.
func (in *DockerRepositoryStatus) DeepCopy() *DockerRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(DockerRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GemsRepository) DeepCopyInto(out *GemsRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GemsRepository.
func (in *GemsRepository) DeepCopy() *GemsRepository {
	if in == nil {
		return nil
	}
	out := new(GemsRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GemsRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GemsRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *GemsRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GemsRepositoryContentSynchronisationInitParameters.
func (in *GemsRepositoryContentSynchronisationInitParameters) DeepCopy() *GemsRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(GemsRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GemsRepositoryContentSynchronisationObservation) DeepCopyInto(out *GemsRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GemsRepositoryContentSynchronisationObservation.
func (in *GemsRepositoryContentSynchronisationObservation) DeepCopy() *GemsRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(GemsRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GemsRepositoryContentSynchronisationParameters) DeepCopyInto(out *GemsRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GemsRepositoryContentSynchronisationParameters.
func (in *GemsRepositoryContentSynchronisationParameters) DeepCopy() *GemsRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(GemsRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GemsRepositoryInitParameters) DeepCopyInto(out *GemsRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GemsRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GemsRepositoryInitParameters.
func (in *GemsRepositoryInitParameters) DeepCopy() *GemsRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(GemsRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GemsRepositoryList) DeepCopyInto(out *GemsRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]GemsRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GemsRepositoryList.
func (in *GemsRepositoryList) DeepCopy() *GemsRepositoryList {
	if in == nil {
		return nil
	}
	out := new(GemsRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GemsRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GemsRepositoryObservation) DeepCopyInto(out *GemsRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GemsRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GemsRepositoryObservation.
func (in *GemsRepositoryObservation) DeepCopy() *GemsRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(GemsRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GemsRepositoryParameters) DeepCopyInto(out *GemsRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GemsRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GemsRepositoryParameters.
func (in *GemsRepositoryParameters) DeepCopy() *GemsRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(GemsRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GemsRepositorySpec) DeepCopyInto(out *GemsRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GemsRepositorySpec.
func (in *GemsRepositorySpec) DeepCopy() *GemsRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(GemsRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GemsRepositoryStatus) DeepCopyInto(out *GemsRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GemsRepositoryStatus.
func (in *GemsRepositoryStatus) DeepCopy() *GemsRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(GemsRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenericRepository) DeepCopyInto(out *GenericRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericRepository.
func (in *GenericRepository) DeepCopy() *GenericRepository {
	if in == nil {
		return nil
	}
	out := new(GenericRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GenericRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenericRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *GenericRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericRepositoryContentSynchronisationInitParameters.
func (in *GenericRepositoryContentSynchronisationInitParameters) DeepCopy() *GenericRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(GenericRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenericRepositoryContentSynchronisationObservation) DeepCopyInto(out *GenericRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericRepositoryContentSynchronisationObservation.
func (in *GenericRepositoryContentSynchronisationObservation) DeepCopy() *GenericRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(GenericRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenericRepositoryContentSynchronisationParameters) DeepCopyInto(out *GenericRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericRepositoryContentSynchronisationParameters.
func (in *GenericRepositoryContentSynchronisationParameters) DeepCopy() *GenericRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(GenericRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenericRepositoryInitParameters) DeepCopyInto(out *GenericRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GenericRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericRepositoryInitParameters.
func (in *GenericRepositoryInitParameters) DeepCopy() *GenericRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(GenericRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenericRepositoryList) DeepCopyInto(out *GenericRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]GenericRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericRepositoryList.
func (in *GenericRepositoryList) DeepCopy() *GenericRepositoryList {
	if in == nil {
		return nil
	}
	out := new(GenericRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GenericRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenericRepositoryObservation) DeepCopyInto(out *GenericRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GenericRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericRepositoryObservation.
func (in *GenericRepositoryObservation) DeepCopy() *GenericRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(GenericRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenericRepositoryParameters) DeepCopyInto(out *GenericRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GenericRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericRepositoryParameters.
func (in *GenericRepositoryParameters) DeepCopy() *GenericRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(GenericRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenericRepositorySpec) DeepCopyInto(out *GenericRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericRepositorySpec.
func (in *GenericRepositorySpec) DeepCopy() *GenericRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(GenericRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GenericRepositoryStatus) DeepCopyInto(out *GenericRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GenericRepositoryStatus.
func (in *GenericRepositoryStatus) DeepCopy() *GenericRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(GenericRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitLFSRepository) DeepCopyInto(out *GitLFSRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitLFSRepository.
func (in *GitLFSRepository) DeepCopy() *GitLFSRepository {
	if in == nil {
		return nil
	}
	out := new(GitLFSRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GitLFSRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitLFSRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *GitLFSRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitLFSRepositoryContentSynchronisationInitParameters.
func (in *GitLFSRepositoryContentSynchronisationInitParameters) DeepCopy() *GitLFSRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(GitLFSRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitLFSRepositoryContentSynchronisationObservation) DeepCopyInto(out *GitLFSRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitLFSRepositoryContentSynchronisationObservation.
func (in *GitLFSRepositoryContentSynchronisationObservation) DeepCopy() *GitLFSRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(GitLFSRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitLFSRepositoryContentSynchronisationParameters) DeepCopyInto(out *GitLFSRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitLFSRepositoryContentSynchronisationParameters.
func (in *GitLFSRepositoryContentSynchronisationParameters) DeepCopy() *GitLFSRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(GitLFSRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitLFSRepositoryInitParameters) DeepCopyInto(out *GitLFSRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GitLFSRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitLFSRepositoryInitParameters.
func (in *GitLFSRepositoryInitParameters) DeepCopy() *GitLFSRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(GitLFSRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitLFSRepositoryList) DeepCopyInto(out *GitLFSRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]GitLFSRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitLFSRepositoryList.
func (in *GitLFSRepositoryList) DeepCopy() *GitLFSRepositoryList {
	if in == nil {
		return nil
	}
	out := new(GitLFSRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GitLFSRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitLFSRepositoryObservation) DeepCopyInto(out *GitLFSRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GitLFSRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitLFSRepositoryObservation.
func (in *GitLFSRepositoryObservation) DeepCopy() *GitLFSRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(GitLFSRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitLFSRepositoryParameters) DeepCopyInto(out *GitLFSRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GitLFSRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitLFSRepositoryParameters.
func (in *GitLFSRepositoryParameters) DeepCopy() *GitLFSRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(GitLFSRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitLFSRepositorySpec) DeepCopyInto(out *GitLFSRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitLFSRepositorySpec.
func (in *GitLFSRepositorySpec) DeepCopy() *GitLFSRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(GitLFSRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitLFSRepositoryStatus) DeepCopyInto(out *GitLFSRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitLFSRepositoryStatus.
func (in *GitLFSRepositoryStatus) DeepCopy() *GitLFSRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(GitLFSRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GoRepository) DeepCopyInto(out *GoRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GoRepository.
func (in *GoRepository) DeepCopy() *GoRepository {
	if in == nil {
		return nil
	}
	out := new(GoRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GoRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GoRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *GoRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GoRepositoryContentSynchronisationInitParameters.
func (in *GoRepositoryContentSynchronisationInitParameters) DeepCopy() *GoRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(GoRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GoRepositoryContentSynchronisationObservation) DeepCopyInto(out *GoRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GoRepositoryContentSynchronisationObservation.
func (in *GoRepositoryContentSynchronisationObservation) DeepCopy() *GoRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(GoRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GoRepositoryContentSynchronisationParameters) DeepCopyInto(out *GoRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GoRepositoryContentSynchronisationParameters.
func (in *GoRepositoryContentSynchronisationParameters) DeepCopy() *GoRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(GoRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GoRepositoryInitParameters) DeepCopyInto(out *GoRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GoRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GoRepositoryInitParameters.
func (in *GoRepositoryInitParameters) DeepCopy() *GoRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(GoRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GoRepositoryList) DeepCopyInto(out *GoRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]GoRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GoRepositoryList.
func (in *GoRepositoryList) DeepCopy() *GoRepositoryList {
	if in == nil {
		return nil
	}
	out := new(GoRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GoRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GoRepositoryObservation) DeepCopyInto(out *GoRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GoRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GoRepositoryObservation.
func (in *GoRepositoryObservation) DeepCopy() *GoRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(GoRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GoRepositoryParameters) DeepCopyInto(out *GoRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GoRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropagateQueryParams != nil {
		in, out := &in.PropagateQueryParams, &out.PropagateQueryParams
		*out = new(bool)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.RetrieveSha256FromServer != nil {
		in, out := &in.RetrieveSha256FromServer, &out.RetrieveSha256FromServer
		*out = new(bool)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GoRepositoryParameters.
func (in *GoRepositoryParameters) DeepCopy() *GoRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(GoRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GoRepositorySpec) DeepCopyInto(out *GoRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GoRepositorySpec.
func (in *GoRepositorySpec) DeepCopy() *GoRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(GoRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GoRepositoryStatus) DeepCopyInto(out *GoRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GoRepositoryStatus.
func (in *GoRepositoryStatus) DeepCopy() *GoRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(GoRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GradleRepository) DeepCopyInto(out *GradleRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GradleRepository.
func (in *GradleRepository) DeepCopy() *GradleRepository {
	if in == nil {
		return nil
	}
	out := new(GradleRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GradleRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GradleRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *GradleRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GradleRepositoryContentSynchronisationInitParameters.
func (in *GradleRepositoryContentSynchronisationInitParameters) DeepCopy() *GradleRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(GradleRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GradleRepositoryContentSynchronisationObservation) DeepCopyInto(out *GradleRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GradleRepositoryContentSynchronisationObservation.
func (in *GradleRepositoryContentSynchronisationObservation) DeepCopy() *GradleRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(GradleRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GradleRepositoryContentSynchronisationParameters) DeepCopyInto(out *GradleRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GradleRepositoryContentSynchronisationParameters.
func (in *GradleRepositoryContentSynchronisationParameters) DeepCopy() *GradleRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(GradleRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GradleRepositoryInitParameters) DeepCopyInto(out *GradleRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GradleRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GradleRepositoryInitParameters.
func (in *GradleRepositoryInitParameters) DeepCopy() *GradleRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(GradleRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GradleRepositoryList) DeepCopyInto(out *GradleRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]GradleRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GradleRepositoryList.
func (in *GradleRepositoryList) DeepCopy() *GradleRepositoryList {
	if in == nil {
		return nil
	}
	out := new(GradleRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GradleRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GradleRepositoryObservation) DeepCopyInto(out *GradleRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GradleRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GradleRepositoryObservation.
func (in *GradleRepositoryObservation) DeepCopy() *GradleRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(GradleRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GradleRepositoryParameters) DeepCopyInto(out *GradleRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]GradleRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GradleRepositoryParameters.
func (in *GradleRepositoryParameters) DeepCopy() *GradleRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(GradleRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GradleRepositorySpec) DeepCopyInto(out *GradleRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GradleRepositorySpec.
func (in *GradleRepositorySpec) DeepCopy() *GradleRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(GradleRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GradleRepositoryStatus) DeepCopyInto(out *GradleRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GradleRepositoryStatus.
func (in *GradleRepositoryStatus) DeepCopy() *GradleRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(GradleRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmOCIRepository) DeepCopyInto(out *HelmOCIRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmOCIRepository.
func (in *HelmOCIRepository) DeepCopy() *HelmOCIRepository {
	if in == nil {
		return nil
	}
	out := new(HelmOCIRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *HelmOCIRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmOCIRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *HelmOCIRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmOCIRepositoryContentSynchronisationInitParameters.
func (in *HelmOCIRepositoryContentSynchronisationInitParameters) DeepCopy() *HelmOCIRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(HelmOCIRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmOCIRepositoryContentSynchronisationObservation) DeepCopyInto(out *HelmOCIRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmOCIRepositoryContentSynchronisationObservation.
func (in *HelmOCIRepositoryContentSynchronisationObservation) DeepCopy() *HelmOCIRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(HelmOCIRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmOCIRepositoryContentSynchronisationParameters) DeepCopyInto(out *HelmOCIRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmOCIRepositoryContentSynchronisationParameters.
func (in *HelmOCIRepositoryContentSynchronisationParameters) DeepCopy() *HelmOCIRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(HelmOCIRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmOCIRepositoryInitParameters) DeepCopyInto(out *HelmOCIRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]HelmOCIRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmOCIRepositoryInitParameters.
func (in *HelmOCIRepositoryInitParameters) DeepCopy() *HelmOCIRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(HelmOCIRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmOCIRepositoryList) DeepCopyInto(out *HelmOCIRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]HelmOCIRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmOCIRepositoryList.
func (in *HelmOCIRepositoryList) DeepCopy() *HelmOCIRepositoryList {
	if in == nil {
		return nil
	}
	out := new(HelmOCIRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *HelmOCIRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmOCIRepositoryObservation) DeepCopyInto(out *HelmOCIRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]HelmOCIRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmOCIRepositoryObservation.
func (in *HelmOCIRepositoryObservation) DeepCopy() *HelmOCIRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(HelmOCIRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmOCIRepositoryParameters) DeepCopyInto(out *HelmOCIRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]HelmOCIRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmOCIRepositoryParameters.
func (in *HelmOCIRepositoryParameters) DeepCopy() *HelmOCIRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(HelmOCIRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmOCIRepositorySpec) DeepCopyInto(out *HelmOCIRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmOCIRepositorySpec.
func (in *HelmOCIRepositorySpec) DeepCopy() *HelmOCIRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(HelmOCIRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmOCIRepositoryStatus) DeepCopyInto(out *HelmOCIRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmOCIRepositoryStatus.
func (in *HelmOCIRepositoryStatus) DeepCopy() *HelmOCIRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(HelmOCIRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmRepository) DeepCopyInto(out *HelmRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmRepository.
func (in *HelmRepository) DeepCopy() *HelmRepository {
	if in == nil {
		return nil
	}
	out := new(HelmRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *HelmRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *HelmRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmRepositoryContentSynchronisationInitParameters.
func (in *HelmRepositoryContentSynchronisationInitParameters) DeepCopy() *HelmRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(HelmRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmRepositoryContentSynchronisationObservation) DeepCopyInto(out *HelmRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmRepositoryContentSynchronisationObservation.
func (in *HelmRepositoryContentSynchronisationObservation) DeepCopy() *HelmRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(HelmRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmRepositoryContentSynchronisationParameters) DeepCopyInto(out *HelmRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmRepositoryContentSynchronisationParameters.
func (in *HelmRepositoryContentSynchronisationParameters) DeepCopy() *HelmRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(HelmRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmRepositoryInitParameters) DeepCopyInto(out *HelmRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]HelmRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.HelmChartsBaseURL != nil {
		in, out := &in.HelmChartsBaseURL, &out.HelmChartsBaseURL
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmRepositoryInitParameters.
func (in *HelmRepositoryInitParameters) DeepCopy() *HelmRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(HelmRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmRepositoryList) DeepCopyInto(out *HelmRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]HelmRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmRepositoryList.
func (in *HelmRepositoryList) DeepCopy() *HelmRepositoryList {
	if in == nil {
		return nil
	}
	out := new(HelmRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *HelmRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmRepositoryObservation) DeepCopyInto(out *HelmRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]HelmRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.HelmChartsBaseURL != nil {
		in, out := &in.HelmChartsBaseURL, &out.HelmChartsBaseURL
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmRepositoryObservation.
func (in *HelmRepositoryObservation) DeepCopy() *HelmRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(HelmRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmRepositoryParameters) DeepCopyInto(out *HelmRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]HelmRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.HelmChartsBaseURL != nil {
		in, out := &in.HelmChartsBaseURL, &out.HelmChartsBaseURL
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmRepositoryParameters.
func (in *HelmRepositoryParameters) DeepCopy() *HelmRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(HelmRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmRepositorySpec) DeepCopyInto(out *HelmRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmRepositorySpec.
func (in *HelmRepositorySpec) DeepCopy() *HelmRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(HelmRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HelmRepositoryStatus) DeepCopyInto(out *HelmRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HelmRepositoryStatus.
func (in *HelmRepositoryStatus) DeepCopy() *HelmRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(HelmRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HuggingfacemlRepository) DeepCopyInto(out *HuggingfacemlRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HuggingfacemlRepository.
func (in *HuggingfacemlRepository) DeepCopy() *HuggingfacemlRepository {
	if in == nil {
		return nil
	}
	out := new(HuggingfacemlRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *HuggingfacemlRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HuggingfacemlRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *HuggingfacemlRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HuggingfacemlRepositoryContentSynchronisationInitParameters.
func (in *HuggingfacemlRepositoryContentSynchronisationInitParameters) DeepCopy() *HuggingfacemlRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(HuggingfacemlRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HuggingfacemlRepositoryContentSynchronisationObservation) DeepCopyInto(out *HuggingfacemlRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HuggingfacemlRepositoryContentSynchronisationObservation.
func (in *HuggingfacemlRepositoryContentSynchronisationObservation) DeepCopy() *HuggingfacemlRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(HuggingfacemlRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HuggingfacemlRepositoryContentSynchronisationParameters) DeepCopyInto(out *HuggingfacemlRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HuggingfacemlRepositoryContentSynchronisationParameters.
func (in *HuggingfacemlRepositoryContentSynchronisationParameters) DeepCopy() *HuggingfacemlRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(HuggingfacemlRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HuggingfacemlRepositoryInitParameters) DeepCopyInto(out *HuggingfacemlRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]HuggingfacemlRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HuggingfacemlRepositoryInitParameters.
func (in *HuggingfacemlRepositoryInitParameters) DeepCopy() *HuggingfacemlRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(HuggingfacemlRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HuggingfacemlRepositoryList) DeepCopyInto(out *HuggingfacemlRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]HuggingfacemlRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HuggingfacemlRepositoryList.
func (in *HuggingfacemlRepositoryList) DeepCopy() *HuggingfacemlRepositoryList {
	if in == nil {
		return nil
	}
	out := new(HuggingfacemlRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *HuggingfacemlRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HuggingfacemlRepositoryObservation) DeepCopyInto(out *HuggingfacemlRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]HuggingfacemlRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HuggingfacemlRepositoryObservation.
func (in *HuggingfacemlRepositoryObservation) DeepCopy() *HuggingfacemlRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(HuggingfacemlRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HuggingfacemlRepositoryParameters) DeepCopyInto(out *HuggingfacemlRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]HuggingfacemlRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HuggingfacemlRepositoryParameters.
func (in *HuggingfacemlRepositoryParameters) DeepCopy() *HuggingfacemlRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(HuggingfacemlRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HuggingfacemlRepositorySpec) DeepCopyInto(out *HuggingfacemlRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HuggingfacemlRepositorySpec.
func (in *HuggingfacemlRepositorySpec) DeepCopy() *HuggingfacemlRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(HuggingfacemlRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *HuggingfacemlRepositoryStatus) DeepCopyInto(out *HuggingfacemlRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new HuggingfacemlRepositoryStatus.
func (in *HuggingfacemlRepositoryStatus) DeepCopy() *HuggingfacemlRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(HuggingfacemlRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IvyRepository) DeepCopyInto(out *IvyRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IvyRepository.
func (in *IvyRepository) DeepCopy() *IvyRepository {
	if in == nil {
		return nil
	}
	out := new(IvyRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *IvyRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IvyRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *IvyRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IvyRepositoryContentSynchronisationInitParameters.
func (in *IvyRepositoryContentSynchronisationInitParameters) DeepCopy() *IvyRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(IvyRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IvyRepositoryContentSynchronisationObservation) DeepCopyInto(out *IvyRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IvyRepositoryContentSynchronisationObservation.
func (in *IvyRepositoryContentSynchronisationObservation) DeepCopy() *IvyRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(IvyRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IvyRepositoryContentSynchronisationParameters) DeepCopyInto(out *IvyRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IvyRepositoryContentSynchronisationParameters.
func (in *IvyRepositoryContentSynchronisationParameters) DeepCopy() *IvyRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(IvyRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IvyRepositoryInitParameters) DeepCopyInto(out *IvyRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]IvyRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IvyRepositoryInitParameters.
func (in *IvyRepositoryInitParameters) DeepCopy() *IvyRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(IvyRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IvyRepositoryList) DeepCopyInto(out *IvyRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]IvyRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IvyRepositoryList.
func (in *IvyRepositoryList) DeepCopy() *IvyRepositoryList {
	if in == nil {
		return nil
	}
	out := new(IvyRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *IvyRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IvyRepositoryObservation) DeepCopyInto(out *IvyRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]IvyRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IvyRepositoryObservation.
func (in *IvyRepositoryObservation) DeepCopy() *IvyRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(IvyRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IvyRepositoryParameters) DeepCopyInto(out *IvyRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]IvyRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IvyRepositoryParameters.
func (in *IvyRepositoryParameters) DeepCopy() *IvyRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(IvyRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IvyRepositorySpec) DeepCopyInto(out *IvyRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IvyRepositorySpec.
func (in *IvyRepositorySpec) DeepCopy() *IvyRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(IvyRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *IvyRepositoryStatus) DeepCopyInto(out *IvyRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new IvyRepositoryStatus.
func (in *IvyRepositoryStatus) DeepCopy() *IvyRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(IvyRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MavenRepository) DeepCopyInto(out *MavenRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepository.
func (in *MavenRepository) DeepCopy() *MavenRepository {
	if in == nil {
		return nil
	}
	out := new(MavenRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *MavenRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MavenRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *MavenRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepositoryContentSynchronisationInitParameters.
func (in *MavenRepositoryContentSynchronisationInitParameters) DeepCopy() *MavenRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(MavenRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MavenRepositoryContentSynchronisationObservation) DeepCopyInto(out *MavenRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepositoryContentSynchronisationObservation.
func (in *MavenRepositoryContentSynchronisationObservation) DeepCopy() *MavenRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(MavenRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MavenRepositoryContentSynchronisationParameters) DeepCopyInto(out *MavenRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepositoryContentSynchronisationParameters.
func (in *MavenRepositoryContentSynchronisationParameters) DeepCopy() *MavenRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(MavenRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MavenRepositoryInitParameters) DeepCopyInto(out *MavenRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]MavenRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepositoryInitParameters.
func (in *MavenRepositoryInitParameters) DeepCopy() *MavenRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(MavenRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MavenRepositoryList) DeepCopyInto(out *MavenRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]MavenRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepositoryList.
func (in *MavenRepositoryList) DeepCopy() *MavenRepositoryList {
	if in == nil {
		return nil
	}
	out := new(MavenRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *MavenRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MavenRepositoryObservation) DeepCopyInto(out *MavenRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]MavenRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepositoryObservation.
func (in *MavenRepositoryObservation) DeepCopy() *MavenRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(MavenRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MavenRepositoryParameters) DeepCopyInto(out *MavenRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]MavenRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepositoryParameters.
func (in *MavenRepositoryParameters) DeepCopy() *MavenRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(MavenRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MavenRepositorySpec) DeepCopyInto(out *MavenRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepositorySpec.
func (in *MavenRepositorySpec) DeepCopy() *MavenRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(MavenRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *MavenRepositoryStatus) DeepCopyInto(out *MavenRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new MavenRepositoryStatus.
func (in *MavenRepositoryStatus) DeepCopy() *MavenRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(MavenRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NpmRepository) DeepCopyInto(out *NpmRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepository.
func (in *NpmRepository) DeepCopy() *NpmRepository {
	if in == nil {
		return nil
	}
	out := new(NpmRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NpmRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NpmRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *NpmRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepositoryContentSynchronisationInitParameters.
func (in *NpmRepositoryContentSynchronisationInitParameters) DeepCopy() *NpmRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(NpmRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NpmRepositoryContentSynchronisationObservation) DeepCopyInto(out *NpmRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepositoryContentSynchronisationObservation.
func (in *NpmRepositoryContentSynchronisationObservation) DeepCopy() *NpmRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(NpmRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NpmRepositoryContentSynchronisationParameters) DeepCopyInto(out *NpmRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepositoryContentSynchronisationParameters.
func (in *NpmRepositoryContentSynchronisationParameters) DeepCopy() *NpmRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(NpmRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NpmRepositoryInitParameters) DeepCopyInto(out *NpmRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]NpmRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepositoryInitParameters.
func (in *NpmRepositoryInitParameters) DeepCopy() *NpmRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(NpmRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NpmRepositoryList) DeepCopyInto(out *NpmRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]NpmRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepositoryList.
func (in *NpmRepositoryList) DeepCopy() *NpmRepositoryList {
	if in == nil {
		return nil
	}
	out := new(NpmRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NpmRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NpmRepositoryObservation) DeepCopyInto(out *NpmRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]NpmRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepositoryObservation.
func (in *NpmRepositoryObservation) DeepCopy() *NpmRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(NpmRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NpmRepositoryParameters) DeepCopyInto(out *NpmRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]NpmRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepositoryParameters.
func (in *NpmRepositoryParameters) DeepCopy() *NpmRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(NpmRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NpmRepositorySpec) DeepCopyInto(out *NpmRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepositorySpec.
func (in *NpmRepositorySpec) DeepCopy() *NpmRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(NpmRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NpmRepositoryStatus) DeepCopyInto(out *NpmRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NpmRepositoryStatus.
func (in *NpmRepositoryStatus) DeepCopy() *NpmRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(NpmRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NugetRepository) DeepCopyInto(out *NugetRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NugetRepository.
func (in *NugetRepository) DeepCopy() *NugetRepository {
	if in == nil {
		return nil
	}
	out := new(NugetRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NugetRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NugetRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *NugetRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NugetRepositoryContentSynchronisationInitParameters.
func (in *NugetRepositoryContentSynchronisationInitParameters) DeepCopy() *NugetRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(NugetRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NugetRepositoryContentSynchronisationObservation) DeepCopyInto(out *NugetRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NugetRepositoryContentSynchronisationObservation.
func (in *NugetRepositoryContentSynchronisationObservation) DeepCopy() *NugetRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(NugetRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NugetRepositoryContentSynchronisationParameters) DeepCopyInto(out *NugetRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NugetRepositoryContentSynchronisationParameters.
func (in *NugetRepositoryContentSynchronisationParameters) DeepCopy() *NugetRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(NugetRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NugetRepositoryInitParameters) DeepCopyInto(out *NugetRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]NugetRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadContextPath != nil {
		in, out := &in.DownloadContextPath, &out.DownloadContextPath
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FeedContextPath != nil {
		in, out := &in.FeedContextPath, &out.FeedContextPath
		*out = new(string)
		**out = **in
	}
	if in.ForceNugetAuthentication != nil {
		in, out := &in.ForceNugetAuthentication, &out.ForceNugetAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SymbolServerURL != nil {
		in, out := &in.SymbolServerURL, &out.SymbolServerURL
		*out = new(string)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.V3FeedURL != nil {
		in, out := &in.V3FeedURL, &out.V3FeedURL
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NugetRepositoryInitParameters.
func (in *NugetRepositoryInitParameters) DeepCopy() *NugetRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(NugetRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NugetRepositoryList) DeepCopyInto(out *NugetRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]NugetRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NugetRepositoryList.
func (in *NugetRepositoryList) DeepCopy() *NugetRepositoryList {
	if in == nil {
		return nil
	}
	out := new(NugetRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *NugetRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NugetRepositoryObservation) DeepCopyInto(out *NugetRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]NugetRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadContextPath != nil {
		in, out := &in.DownloadContextPath, &out.DownloadContextPath
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FeedContextPath != nil {
		in, out := &in.FeedContextPath, &out.FeedContextPath
		*out = new(string)
		**out = **in
	}
	if in.ForceNugetAuthentication != nil {
		in, out := &in.ForceNugetAuthentication, &out.ForceNugetAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SymbolServerURL != nil {
		in, out := &in.SymbolServerURL, &out.SymbolServerURL
		*out = new(string)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.V3FeedURL != nil {
		in, out := &in.V3FeedURL, &out.V3FeedURL
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NugetRepositoryObservation.
func (in *NugetRepositoryObservation) DeepCopy() *NugetRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(NugetRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NugetRepositoryParameters) DeepCopyInto(out *NugetRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]NugetRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadContextPath != nil {
		in, out := &in.DownloadContextPath, &out.DownloadContextPath
		*out = new(string)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FeedContextPath != nil {
		in, out := &in.FeedContextPath, &out.FeedContextPath
		*out = new(string)
		**out = **in
	}
	if in.ForceNugetAuthentication != nil {
		in, out := &in.ForceNugetAuthentication, &out.ForceNugetAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SymbolServerURL != nil {
		in, out := &in.SymbolServerURL, &out.SymbolServerURL
		*out = new(string)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.V3FeedURL != nil {
		in, out := &in.V3FeedURL, &out.V3FeedURL
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NugetRepositoryParameters.
func (in *NugetRepositoryParameters) DeepCopy() *NugetRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(NugetRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NugetRepositorySpec) DeepCopyInto(out *NugetRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NugetRepositorySpec.
func (in *NugetRepositorySpec) DeepCopy() *NugetRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(NugetRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *NugetRepositoryStatus) DeepCopyInto(out *NugetRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new NugetRepositoryStatus.
func (in *NugetRepositoryStatus) DeepCopy() *NugetRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(NugetRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OCIRepository) DeepCopyInto(out *OCIRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OCIRepository.
func (in *OCIRepository) DeepCopy() *OCIRepository {
	if in == nil {
		return nil
	}
	out := new(OCIRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OCIRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OCIRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *OCIRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OCIRepositoryContentSynchronisationInitParameters.
func (in *OCIRepositoryContentSynchronisationInitParameters) DeepCopy() *OCIRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(OCIRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OCIRepositoryContentSynchronisationObservation) DeepCopyInto(out *OCIRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OCIRepositoryContentSynchronisationObservation.
func (in *OCIRepositoryContentSynchronisationObservation) DeepCopy() *OCIRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(OCIRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OCIRepositoryContentSynchronisationParameters) DeepCopyInto(out *OCIRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OCIRepositoryContentSynchronisationParameters.
func (in *OCIRepositoryContentSynchronisationParameters) DeepCopy() *OCIRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(OCIRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OCIRepositoryInitParameters) DeepCopyInto(out *OCIRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]OCIRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OCIRepositoryInitParameters.
func (in *OCIRepositoryInitParameters) DeepCopy() *OCIRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(OCIRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OCIRepositoryList) DeepCopyInto(out *OCIRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]OCIRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OCIRepositoryList.
func (in *OCIRepositoryList) DeepCopy() *OCIRepositoryList {
	if in == nil {
		return nil
	}
	out := new(OCIRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OCIRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OCIRepositoryObservation) DeepCopyInto(out *OCIRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]OCIRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OCIRepositoryObservation.
func (in *OCIRepositoryObservation) DeepCopy() *OCIRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(OCIRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OCIRepositoryParameters) DeepCopyInto(out *OCIRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]OCIRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.EnableTokenAuthentication != nil {
		in, out := &in.EnableTokenAuthentication, &out.EnableTokenAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ExternalDependenciesEnabled != nil {
		in, out := &in.ExternalDependenciesEnabled, &out.ExternalDependenciesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExternalDependenciesPatterns != nil {
		in, out := &in.ExternalDependenciesPatterns, &out.ExternalDependenciesPatterns
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectID != nil {
		in, out := &in.ProjectID, &out.ProjectID
		*out = new(string)
		**out = **in
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OCIRepositoryParameters.
func (in *OCIRepositoryParameters) DeepCopy() *OCIRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(OCIRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OCIRepositorySpec) DeepCopyInto(out *OCIRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OCIRepositorySpec.
func (in *OCIRepositorySpec) DeepCopy() *OCIRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(OCIRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OCIRepositoryStatus) DeepCopyInto(out *OCIRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OCIRepositoryStatus.
func (in *OCIRepositoryStatus) DeepCopy() *OCIRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(OCIRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpkgRepository) DeepCopyInto(out *OpkgRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpkgRepository.
func (in *OpkgRepository) DeepCopy() *OpkgRepository {
	if in == nil {
		return nil
	}
	out := new(OpkgRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpkgRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpkgRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *OpkgRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpkgRepositoryContentSynchronisationInitParameters.
func (in *OpkgRepositoryContentSynchronisationInitParameters) DeepCopy() *OpkgRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(OpkgRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpkgRepositoryContentSynchronisationObservation) DeepCopyInto(out *OpkgRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpkgRepositoryContentSynchronisationObservation.
func (in *OpkgRepositoryContentSynchronisationObservation) DeepCopy() *OpkgRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(OpkgRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpkgRepositoryContentSynchronisationParameters) DeepCopyInto(out *OpkgRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpkgRepositoryContentSynchronisationParameters.
func (in *OpkgRepositoryContentSynchronisationParameters) DeepCopy() *OpkgRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(OpkgRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpkgRepositoryInitParameters) DeepCopyInto(out *OpkgRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]OpkgRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpkgRepositoryInitParameters.
func (in *OpkgRepositoryInitParameters) DeepCopy() *OpkgRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(OpkgRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpkgRepositoryList) DeepCopyInto(out *OpkgRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]OpkgRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpkgRepositoryList.
func (in *OpkgRepositoryList) DeepCopy() *OpkgRepositoryList {
	if in == nil {
		return nil
	}
	out := new(OpkgRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *OpkgRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpkgRepositoryObservation) DeepCopyInto(out *OpkgRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]OpkgRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpkgRepositoryObservation.
func (in *OpkgRepositoryObservation) DeepCopy() *OpkgRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(OpkgRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpkgRepositoryParameters) DeepCopyInto(out *OpkgRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]OpkgRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpkgRepositoryParameters.
func (in *OpkgRepositoryParameters) DeepCopy() *OpkgRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(OpkgRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpkgRepositorySpec) DeepCopyInto(out *OpkgRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpkgRepositorySpec.
func (in *OpkgRepositorySpec) DeepCopy() *OpkgRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(OpkgRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *OpkgRepositoryStatus) DeepCopyInto(out *OpkgRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new OpkgRepositoryStatus.
func (in *OpkgRepositoryStatus) DeepCopy() *OpkgRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(OpkgRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *P2Repository) DeepCopyInto(out *P2Repository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new P2Repository.
func (in *P2Repository) DeepCopy() *P2Repository {
	if in == nil {
		return nil
	}
	out := new(P2Repository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *P2Repository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *P2RepositoryContentSynchronisationInitParameters) DeepCopyInto(out *P2RepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new P2RepositoryContentSynchronisationInitParameters.
func (in *P2RepositoryContentSynchronisationInitParameters) DeepCopy() *P2RepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(P2RepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *P2RepositoryContentSynchronisationObservation) DeepCopyInto(out *P2RepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new P2RepositoryContentSynchronisationObservation.
func (in *P2RepositoryContentSynchronisationObservation) DeepCopy() *P2RepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(P2RepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *P2RepositoryContentSynchronisationParameters) DeepCopyInto(out *P2RepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new P2RepositoryContentSynchronisationParameters.
func (in *P2RepositoryContentSynchronisationParameters) DeepCopy() *P2RepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(P2RepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *P2RepositoryInitParameters) DeepCopyInto(out *P2RepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]P2RepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new P2RepositoryInitParameters.
func (in *P2RepositoryInitParameters) DeepCopy() *P2RepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(P2RepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *P2RepositoryList) DeepCopyInto(out *P2RepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]P2Repository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new P2RepositoryList.
func (in *P2RepositoryList) DeepCopy() *P2RepositoryList {
	if in == nil {
		return nil
	}
	out := new(P2RepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *P2RepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *P2RepositoryObservation) DeepCopyInto(out *P2RepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]P2RepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new P2RepositoryObservation.
func (in *P2RepositoryObservation) DeepCopy() *P2RepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(P2RepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *P2RepositoryParameters) DeepCopyInto(out *P2RepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]P2RepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new P2RepositoryParameters.
func (in *P2RepositoryParameters) DeepCopy() *P2RepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(P2RepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *P2RepositorySpec) DeepCopyInto(out *P2RepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new P2RepositorySpec.
func (in *P2RepositorySpec) DeepCopy() *P2RepositorySpec {
	if in == nil {
		return nil
	}
	out := new(P2RepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *P2RepositoryStatus) DeepCopyInto(out *P2RepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new P2RepositoryStatus.
func (in *P2RepositoryStatus) DeepCopy() *P2RepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(P2RepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PubRepository) DeepCopyInto(out *PubRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PubRepository.
func (in *PubRepository) DeepCopy() *PubRepository {
	if in == nil {
		return nil
	}
	out := new(PubRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PubRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PubRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *PubRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PubRepositoryContentSynchronisationInitParameters.
func (in *PubRepositoryContentSynchronisationInitParameters) DeepCopy() *PubRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(PubRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PubRepositoryContentSynchronisationObservation) DeepCopyInto(out *PubRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PubRepositoryContentSynchronisationObservation.
func (in *PubRepositoryContentSynchronisationObservation) DeepCopy() *PubRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(PubRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PubRepositoryContentSynchronisationParameters) DeepCopyInto(out *PubRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PubRepositoryContentSynchronisationParameters.
func (in *PubRepositoryContentSynchronisationParameters) DeepCopy() *PubRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(PubRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PubRepositoryInitParameters) DeepCopyInto(out *PubRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]PubRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PubRepositoryInitParameters.
func (in *PubRepositoryInitParameters) DeepCopy() *PubRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(PubRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PubRepositoryList) DeepCopyInto(out *PubRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]PubRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PubRepositoryList.
func (in *PubRepositoryList) DeepCopy() *PubRepositoryList {
	if in == nil {
		return nil
	}
	out := new(PubRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PubRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PubRepositoryObservation) DeepCopyInto(out *PubRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]PubRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PubRepositoryObservation.
func (in *PubRepositoryObservation) DeepCopy() *PubRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(PubRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PubRepositoryParameters) DeepCopyInto(out *PubRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]PubRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PubRepositoryParameters.
func (in *PubRepositoryParameters) DeepCopy() *PubRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(PubRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PubRepositorySpec) DeepCopyInto(out *PubRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PubRepositorySpec.
func (in *PubRepositorySpec) DeepCopy() *PubRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(PubRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PubRepositoryStatus) DeepCopyInto(out *PubRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PubRepositoryStatus.
func (in *PubRepositoryStatus) DeepCopy() *PubRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(PubRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PuppetRepository) DeepCopyInto(out *PuppetRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PuppetRepository.
func (in *PuppetRepository) DeepCopy() *PuppetRepository {
	if in == nil {
		return nil
	}
	out := new(PuppetRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PuppetRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PuppetRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *PuppetRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PuppetRepositoryContentSynchronisationInitParameters.
func (in *PuppetRepositoryContentSynchronisationInitParameters) DeepCopy() *PuppetRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(PuppetRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PuppetRepositoryContentSynchronisationObservation) DeepCopyInto(out *PuppetRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PuppetRepositoryContentSynchronisationObservation.
func (in *PuppetRepositoryContentSynchronisationObservation) DeepCopy() *PuppetRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(PuppetRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PuppetRepositoryContentSynchronisationParameters) DeepCopyInto(out *PuppetRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PuppetRepositoryContentSynchronisationParameters.
func (in *PuppetRepositoryContentSynchronisationParameters) DeepCopy() *PuppetRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(PuppetRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PuppetRepositoryInitParameters) DeepCopyInto(out *PuppetRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]PuppetRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PuppetRepositoryInitParameters.
func (in *PuppetRepositoryInitParameters) DeepCopy() *PuppetRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(PuppetRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PuppetRepositoryList) DeepCopyInto(out *PuppetRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]PuppetRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PuppetRepositoryList.
func (in *PuppetRepositoryList) DeepCopy() *PuppetRepositoryList {
	if in == nil {
		return nil
	}
	out := new(PuppetRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PuppetRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PuppetRepositoryObservation) DeepCopyInto(out *PuppetRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]PuppetRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PuppetRepositoryObservation.
func (in *PuppetRepositoryObservation) DeepCopy() *PuppetRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(PuppetRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PuppetRepositoryParameters) DeepCopyInto(out *PuppetRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]PuppetRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PuppetRepositoryParameters.
func (in *PuppetRepositoryParameters) DeepCopy() *PuppetRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(PuppetRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PuppetRepositorySpec) DeepCopyInto(out *PuppetRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PuppetRepositorySpec.
func (in *PuppetRepositorySpec) DeepCopy() *PuppetRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(PuppetRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PuppetRepositoryStatus) DeepCopyInto(out *PuppetRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PuppetRepositoryStatus.
func (in *PuppetRepositoryStatus) DeepCopy() *PuppetRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(PuppetRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PypiRepository) DeepCopyInto(out *PypiRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PypiRepository.
func (in *PypiRepository) DeepCopy() *PypiRepository {
	if in == nil {
		return nil
	}
	out := new(PypiRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PypiRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PypiRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *PypiRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PypiRepositoryContentSynchronisationInitParameters.
func (in *PypiRepositoryContentSynchronisationInitParameters) DeepCopy() *PypiRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(PypiRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PypiRepositoryContentSynchronisationObservation) DeepCopyInto(out *PypiRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PypiRepositoryContentSynchronisationObservation.
func (in *PypiRepositoryContentSynchronisationObservation) DeepCopy() *PypiRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(PypiRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PypiRepositoryContentSynchronisationParameters) DeepCopyInto(out *PypiRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PypiRepositoryContentSynchronisationParameters.
func (in *PypiRepositoryContentSynchronisationParameters) DeepCopy() *PypiRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(PypiRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PypiRepositoryInitParameters) DeepCopyInto(out *PypiRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]PypiRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.PypiRegistryURL != nil {
		in, out := &in.PypiRegistryURL, &out.PypiRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.PypiRepositorySuffix != nil {
		in, out := &in.PypiRepositorySuffix, &out.PypiRepositorySuffix
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PypiRepositoryInitParameters.
func (in *PypiRepositoryInitParameters) DeepCopy() *PypiRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(PypiRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PypiRepositoryList) DeepCopyInto(out *PypiRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]PypiRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PypiRepositoryList.
func (in *PypiRepositoryList) DeepCopy() *PypiRepositoryList {
	if in == nil {
		return nil
	}
	out := new(PypiRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *PypiRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PypiRepositoryObservation) DeepCopyInto(out *PypiRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]PypiRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.PypiRegistryURL != nil {
		in, out := &in.PypiRegistryURL, &out.PypiRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.PypiRepositorySuffix != nil {
		in, out := &in.PypiRepositorySuffix, &out.PypiRepositorySuffix
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PypiRepositoryObservation.
func (in *PypiRepositoryObservation) DeepCopy() *PypiRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(PypiRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PypiRepositoryParameters) DeepCopyInto(out *PypiRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]PypiRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Curated != nil {
		in, out := &in.Curated, &out.Curated
		*out = new(bool)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.PypiRegistryURL != nil {
		in, out := &in.PypiRegistryURL, &out.PypiRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.PypiRepositorySuffix != nil {
		in, out := &in.PypiRepositorySuffix, &out.PypiRepositorySuffix
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PypiRepositoryParameters.
func (in *PypiRepositoryParameters) DeepCopy() *PypiRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(PypiRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PypiRepositorySpec) DeepCopyInto(out *PypiRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PypiRepositorySpec.
func (in *PypiRepositorySpec) DeepCopy() *PypiRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(PypiRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PypiRepositoryStatus) DeepCopyInto(out *PypiRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PypiRepositoryStatus.
func (in *PypiRepositoryStatus) DeepCopy() *PypiRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(PypiRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPMRepository) DeepCopyInto(out *RPMRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPMRepository.
func (in *RPMRepository) DeepCopy() *RPMRepository {
	if in == nil {
		return nil
	}
	out := new(RPMRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RPMRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPMRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *RPMRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPMRepositoryContentSynchronisationInitParameters.
func (in *RPMRepositoryContentSynchronisationInitParameters) DeepCopy() *RPMRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(RPMRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPMRepositoryContentSynchronisationObservation) DeepCopyInto(out *RPMRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPMRepositoryContentSynchronisationObservation.
func (in *RPMRepositoryContentSynchronisationObservation) DeepCopy() *RPMRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(RPMRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPMRepositoryContentSynchronisationParameters) DeepCopyInto(out *RPMRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPMRepositoryContentSynchronisationParameters.
func (in *RPMRepositoryContentSynchronisationParameters) DeepCopy() *RPMRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(RPMRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPMRepositoryInitParameters) DeepCopyInto(out *RPMRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RPMRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPMRepositoryInitParameters.
func (in *RPMRepositoryInitParameters) DeepCopy() *RPMRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(RPMRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPMRepositoryList) DeepCopyInto(out *RPMRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]RPMRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPMRepositoryList.
func (in *RPMRepositoryList) DeepCopy() *RPMRepositoryList {
	if in == nil {
		return nil
	}
	out := new(RPMRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *RPMRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPMRepositoryObservation) DeepCopyInto(out *RPMRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RPMRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPMRepositoryObservation.
func (in *RPMRepositoryObservation) DeepCopy() *RPMRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(RPMRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPMRepositoryParameters) DeepCopyInto(out *RPMRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]RPMRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPMRepositoryParameters.
func (in *RPMRepositoryParameters) DeepCopy() *RPMRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(RPMRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPMRepositorySpec) DeepCopyInto(out *RPMRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPMRepositorySpec.
func (in *RPMRepositorySpec) DeepCopy() *RPMRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(RPMRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RPMRepositoryStatus) DeepCopyInto(out *RPMRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RPMRepositoryStatus.
func (in *RPMRepositoryStatus) DeepCopy() *RPMRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(RPMRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SbtRepository) DeepCopyInto(out *SbtRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SbtRepository.
func (in *SbtRepository) DeepCopy() *SbtRepository {
	if in == nil {
		return nil
	}
	out := new(SbtRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SbtRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SbtRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *SbtRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SbtRepositoryContentSynchronisationInitParameters.
func (in *SbtRepositoryContentSynchronisationInitParameters) DeepCopy() *SbtRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(SbtRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SbtRepositoryContentSynchronisationObservation) DeepCopyInto(out *SbtRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SbtRepositoryContentSynchronisationObservation.
func (in *SbtRepositoryContentSynchronisationObservation) DeepCopy() *SbtRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(SbtRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SbtRepositoryContentSynchronisationParameters) DeepCopyInto(out *SbtRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SbtRepositoryContentSynchronisationParameters.
func (in *SbtRepositoryContentSynchronisationParameters) DeepCopy() *SbtRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(SbtRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SbtRepositoryInitParameters) DeepCopyInto(out *SbtRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]SbtRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SbtRepositoryInitParameters.
func (in *SbtRepositoryInitParameters) DeepCopy() *SbtRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(SbtRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SbtRepositoryList) DeepCopyInto(out *SbtRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SbtRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SbtRepositoryList.
func (in *SbtRepositoryList) DeepCopy() *SbtRepositoryList {
	if in == nil {
		return nil
	}
	out := new(SbtRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SbtRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SbtRepositoryObservation) DeepCopyInto(out *SbtRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]SbtRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SbtRepositoryObservation.
func (in *SbtRepositoryObservation) DeepCopy() *SbtRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(SbtRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SbtRepositoryParameters) DeepCopyInto(out *SbtRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]SbtRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.FetchJarsEagerly != nil {
		in, out := &in.FetchJarsEagerly, &out.FetchJarsEagerly
		*out = new(bool)
		**out = **in
	}
	if in.FetchSourcesEagerly != nil {
		in, out := &in.FetchSourcesEagerly, &out.FetchSourcesEagerly
		*out = new(bool)
		**out = **in
	}
	if in.HandleReleases != nil {
		in, out := &in.HandleReleases, &out.HandleReleases
		*out = new(bool)
		**out = **in
	}
	if in.HandleSnapshots != nil {
		in, out := &in.HandleSnapshots, &out.HandleSnapshots
		*out = new(bool)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RejectInvalidJars != nil {
		in, out := &in.RejectInvalidJars, &out.RejectInvalidJars
		*out = new(bool)
		**out = **in
	}
	if in.RemoteRepoChecksumPolicyType != nil {
		in, out := &in.RemoteRepoChecksumPolicyType, &out.RemoteRepoChecksumPolicyType
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SuppressPomConsistencyChecks != nil {
		in, out := &in.SuppressPomConsistencyChecks, &out.SuppressPomConsistencyChecks
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SbtRepositoryParameters.
func (in *SbtRepositoryParameters) DeepCopy() *SbtRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(SbtRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SbtRepositorySpec) DeepCopyInto(out *SbtRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SbtRepositorySpec.
func (in *SbtRepositorySpec) DeepCopy() *SbtRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(SbtRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SbtRepositoryStatus) DeepCopyInto(out *SbtRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SbtRepositoryStatus.
func (in *SbtRepositoryStatus) DeepCopy() *SbtRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(SbtRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SwiftRepository) DeepCopyInto(out *SwiftRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SwiftRepository.
func (in *SwiftRepository) DeepCopy() *SwiftRepository {
	if in == nil {
		return nil
	}
	out := new(SwiftRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SwiftRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SwiftRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *SwiftRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SwiftRepositoryContentSynchronisationInitParameters.
func (in *SwiftRepositoryContentSynchronisationInitParameters) DeepCopy() *SwiftRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(SwiftRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SwiftRepositoryContentSynchronisationObservation) DeepCopyInto(out *SwiftRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SwiftRepositoryContentSynchronisationObservation.
func (in *SwiftRepositoryContentSynchronisationObservation) DeepCopy() *SwiftRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(SwiftRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SwiftRepositoryContentSynchronisationParameters) DeepCopyInto(out *SwiftRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SwiftRepositoryContentSynchronisationParameters.
func (in *SwiftRepositoryContentSynchronisationParameters) DeepCopy() *SwiftRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(SwiftRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SwiftRepositoryInitParameters) DeepCopyInto(out *SwiftRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]SwiftRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SwiftRepositoryInitParameters.
func (in *SwiftRepositoryInitParameters) DeepCopy() *SwiftRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(SwiftRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SwiftRepositoryList) DeepCopyInto(out *SwiftRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]SwiftRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SwiftRepositoryList.
func (in *SwiftRepositoryList) DeepCopy() *SwiftRepositoryList {
	if in == nil {
		return nil
	}
	out := new(SwiftRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *SwiftRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SwiftRepositoryObservation) DeepCopyInto(out *SwiftRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]SwiftRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SwiftRepositoryObservation.
func (in *SwiftRepositoryObservation) DeepCopy() *SwiftRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(SwiftRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SwiftRepositoryParameters) DeepCopyInto(out *SwiftRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]SwiftRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SwiftRepositoryParameters.
func (in *SwiftRepositoryParameters) DeepCopy() *SwiftRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(SwiftRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SwiftRepositorySpec) DeepCopyInto(out *SwiftRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SwiftRepositorySpec.
func (in *SwiftRepositorySpec) DeepCopy() *SwiftRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(SwiftRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SwiftRepositoryStatus) DeepCopyInto(out *SwiftRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SwiftRepositoryStatus.
func (in *SwiftRepositoryStatus) DeepCopy() *SwiftRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(SwiftRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformRepository) DeepCopyInto(out *TerraformRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformRepository.
func (in *TerraformRepository) DeepCopy() *TerraformRepository {
	if in == nil {
		return nil
	}
	out := new(TerraformRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *TerraformRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *TerraformRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformRepositoryContentSynchronisationInitParameters.
func (in *TerraformRepositoryContentSynchronisationInitParameters) DeepCopy() *TerraformRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(TerraformRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformRepositoryContentSynchronisationObservation) DeepCopyInto(out *TerraformRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformRepositoryContentSynchronisationObservation.
func (in *TerraformRepositoryContentSynchronisationObservation) DeepCopy() *TerraformRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(TerraformRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformRepositoryContentSynchronisationParameters) DeepCopyInto(out *TerraformRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformRepositoryContentSynchronisationParameters.
func (in *TerraformRepositoryContentSynchronisationParameters) DeepCopy() *TerraformRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(TerraformRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformRepositoryInitParameters) DeepCopyInto(out *TerraformRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]TerraformRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.TerraformProvidersURL != nil {
		in, out := &in.TerraformProvidersURL, &out.TerraformProvidersURL
		*out = new(string)
		**out = **in
	}
	if in.TerraformRegistryURL != nil {
		in, out := &in.TerraformRegistryURL, &out.TerraformRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformRepositoryInitParameters.
func (in *TerraformRepositoryInitParameters) DeepCopy() *TerraformRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(TerraformRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformRepositoryList) DeepCopyInto(out *TerraformRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]TerraformRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformRepositoryList.
func (in *TerraformRepositoryList) DeepCopy() *TerraformRepositoryList {
	if in == nil {
		return nil
	}
	out := new(TerraformRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *TerraformRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformRepositoryObservation) DeepCopyInto(out *TerraformRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]TerraformRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.TerraformProvidersURL != nil {
		in, out := &in.TerraformProvidersURL, &out.TerraformProvidersURL
		*out = new(string)
		**out = **in
	}
	if in.TerraformRegistryURL != nil {
		in, out := &in.TerraformRegistryURL, &out.TerraformRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformRepositoryObservation.
func (in *TerraformRepositoryObservation) DeepCopy() *TerraformRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(TerraformRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformRepositoryParameters) DeepCopyInto(out *TerraformRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]TerraformRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.TerraformProvidersURL != nil {
		in, out := &in.TerraformProvidersURL, &out.TerraformProvidersURL
		*out = new(string)
		**out = **in
	}
	if in.TerraformRegistryURL != nil {
		in, out := &in.TerraformRegistryURL, &out.TerraformRegistryURL
		*out = new(string)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformRepositoryParameters.
func (in *TerraformRepositoryParameters) DeepCopy() *TerraformRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(TerraformRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformRepositorySpec) DeepCopyInto(out *TerraformRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformRepositorySpec.
func (in *TerraformRepositorySpec) DeepCopy() *TerraformRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(TerraformRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TerraformRepositoryStatus) DeepCopyInto(out *TerraformRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TerraformRepositoryStatus.
func (in *TerraformRepositoryStatus) DeepCopy() *TerraformRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(TerraformRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VcsRepository) DeepCopyInto(out *VcsRepository) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VcsRepository.
func (in *VcsRepository) DeepCopy() *VcsRepository {
	if in == nil {
		return nil
	}
	out := new(VcsRepository)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *VcsRepository) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VcsRepositoryContentSynchronisationInitParameters) DeepCopyInto(out *VcsRepositoryContentSynchronisationInitParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VcsRepositoryContentSynchronisationInitParameters.
func (in *VcsRepositoryContentSynchronisationInitParameters) DeepCopy() *VcsRepositoryContentSynchronisationInitParameters {
	if in == nil {
		return nil
	}
	out := new(VcsRepositoryContentSynchronisationInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VcsRepositoryContentSynchronisationObservation) DeepCopyInto(out *VcsRepositoryContentSynchronisationObservation) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VcsRepositoryContentSynchronisationObservation.
func (in *VcsRepositoryContentSynchronisationObservation) DeepCopy() *VcsRepositoryContentSynchronisationObservation {
	if in == nil {
		return nil
	}
	out := new(VcsRepositoryContentSynchronisationObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VcsRepositoryContentSynchronisationParameters) DeepCopyInto(out *VcsRepositoryContentSynchronisationParameters) {
	*out = *in
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.PropertiesEnabled != nil {
		in, out := &in.PropertiesEnabled, &out.PropertiesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SourceOriginAbsenceDetection != nil {
		in, out := &in.SourceOriginAbsenceDetection, &out.SourceOriginAbsenceDetection
		*out = new(bool)
		**out = **in
	}
	if in.StatisticsEnabled != nil {
		in, out := &in.StatisticsEnabled, &out.StatisticsEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VcsRepositoryContentSynchronisationParameters.
func (in *VcsRepositoryContentSynchronisationParameters) DeepCopy() *VcsRepositoryContentSynchronisationParameters {
	if in == nil {
		return nil
	}
	out := new(VcsRepositoryContentSynchronisationParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VcsRepositoryInitParameters) DeepCopyInto(out *VcsRepositoryInitParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]VcsRepositoryContentSynchronisationInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VcsRepositoryInitParameters.
func (in *VcsRepositoryInitParameters) DeepCopy() *VcsRepositoryInitParameters {
	if in == nil {
		return nil
	}
	out := new(VcsRepositoryInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VcsRepositoryList) DeepCopyInto(out *VcsRepositoryList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]VcsRepository, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VcsRepositoryList.
func (in *VcsRepositoryList) DeepCopy() *VcsRepositoryList {
	if in == nil {
		return nil
	}
	out := new(VcsRepositoryList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *VcsRepositoryList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VcsRepositoryObservation) DeepCopyInto(out *VcsRepositoryObservation) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]VcsRepositoryContentSynchronisationObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VcsRepositoryObservation.
func (in *VcsRepositoryObservation) DeepCopy() *VcsRepositoryObservation {
	if in == nil {
		return nil
	}
	out := new(VcsRepositoryObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VcsRepositoryParameters) DeepCopyInto(out *VcsRepositoryParameters) {
	*out = *in
	if in.AllowAnyHostAuth != nil {
		in, out := &in.AllowAnyHostAuth, &out.AllowAnyHostAuth
		*out = new(bool)
		**out = **in
	}
	if in.ArchiveBrowsingEnabled != nil {
		in, out := &in.ArchiveBrowsingEnabled, &out.ArchiveBrowsingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AssumedOfflinePeriodSecs != nil {
		in, out := &in.AssumedOfflinePeriodSecs, &out.AssumedOfflinePeriodSecs
		*out = new(float64)
		**out = **in
	}
	if in.BlackedOut != nil {
		in, out := &in.BlackedOut, &out.BlackedOut
		*out = new(bool)
		**out = **in
	}
	if in.BlockMismatchingMimeTypes != nil {
		in, out := &in.BlockMismatchingMimeTypes, &out.BlockMismatchingMimeTypes
		*out = new(bool)
		**out = **in
	}
	if in.BypassHeadRequests != nil {
		in, out := &in.BypassHeadRequests, &out.BypassHeadRequests
		*out = new(bool)
		**out = **in
	}
	if in.CdnRedirect != nil {
		in, out := &in.CdnRedirect, &out.CdnRedirect
		*out = new(bool)
		**out = **in
	}
	if in.ClientTLSCertificate != nil {
		in, out := &in.ClientTLSCertificate, &out.ClientTLSCertificate
		*out = new(string)
		**out = **in
	}
	if in.ContentSynchronisation != nil {
		in, out := &in.ContentSynchronisation, &out.ContentSynchronisation
		*out = make([]VcsRepositoryContentSynchronisationParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.DisableProxy != nil {
		in, out := &in.DisableProxy, &out.DisableProxy
		*out = new(bool)
		**out = **in
	}
	if in.DisableURLNormalization != nil {
		in, out := &in.DisableURLNormalization, &out.DisableURLNormalization
		*out = new(bool)
		**out = **in
	}
	if in.DownloadDirect != nil {
		in, out := &in.DownloadDirect, &out.DownloadDirect
		*out = new(bool)
		**out = **in
	}
	if in.EnableCookieManagement != nil {
		in, out := &in.EnableCookieManagement, &out.EnableCookieManagement
		*out = new(bool)
		**out = **in
	}
	if in.ExcludesPattern != nil {
		in, out := &in.ExcludesPattern, &out.ExcludesPattern
		*out = new(string)
		**out = **in
	}
	if in.HardFail != nil {
		in, out := &in.HardFail, &out.HardFail
		*out = new(bool)
		**out = **in
	}
	if in.IncludesPattern != nil {
		in, out := &in.IncludesPattern, &out.IncludesPattern
		*out = new(string)
		**out = **in
	}
	if in.ListRemoteFolderItems != nil {
		in, out := &in.ListRemoteFolderItems, &out.ListRemoteFolderItems
		*out = new(bool)
		**out = **in
	}
	if in.LocalAddress != nil {
		in, out := &in.LocalAddress, &out.LocalAddress
		*out = new(string)
		**out = **in
	}
	if in.MaxUniqueSnapshots != nil {
		in, out := &in.MaxUniqueSnapshots, &out.MaxUniqueSnapshots
		*out = new(float64)
		**out = **in
	}
	if in.MetadataRetrievalTimeoutSecs != nil {
		in, out := &in.MetadataRetrievalTimeoutSecs, &out.MetadataRetrievalTimeoutSecs
		*out = new(float64)
		**out = **in
	}
	if in.MismatchingMimeTypesOverrideList != nil {
		in, out := &in.MismatchingMimeTypesOverrideList, &out.MismatchingMimeTypesOverrideList
		*out = new(string)
		**out = **in
	}
	if in.MissedCachePeriodSeconds != nil {
		in, out := &in.MissedCachePeriodSeconds, &out.MissedCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.Notes != nil {
		in, out := &in.Notes, &out.Notes
		*out = new(string)
		**out = **in
	}
	if in.Offline != nil {
		in, out := &in.Offline, &out.Offline
		*out = new(bool)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.SecretKeySelector)
		**out = **in
	}
	if in.PriorityResolution != nil {
		in, out := &in.PriorityResolution, &out.PriorityResolution
		*out = new(bool)
		**out = **in
	}
	if in.ProjectEnvironments != nil {
		in, out := &in.ProjectEnvironments, &out.ProjectEnvironments
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ProjectKey != nil {
		in, out := &in.ProjectKey, &out.ProjectKey
		*out = new(string)
		**out = **in
	}
	if in.PropertySets != nil {
		in, out := &in.PropertySets, &out.PropertySets
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Proxy != nil {
		in, out := &in.Proxy, &out.Proxy
		*out = new(string)
		**out = **in
	}
	if in.QueryParams != nil {
		in, out := &in.QueryParams, &out.QueryParams
		*out = new(string)
		**out = **in
	}
	if in.RemoteRepoLayoutRef != nil {
		in, out := &in.RemoteRepoLayoutRef, &out.RemoteRepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RepoLayoutRef != nil {
		in, out := &in.RepoLayoutRef, &out.RepoLayoutRef
		*out = new(string)
		**out = **in
	}
	if in.RetrievalCachePeriodSeconds != nil {
		in, out := &in.RetrievalCachePeriodSeconds, &out.RetrievalCachePeriodSeconds
		*out = new(float64)
		**out = **in
	}
	if in.ShareConfiguration != nil {
		in, out := &in.ShareConfiguration, &out.ShareConfiguration
		*out = new(bool)
		**out = **in
	}
	if in.SocketTimeoutMillis != nil {
		in, out := &in.SocketTimeoutMillis, &out.SocketTimeoutMillis
		*out = new(float64)
		**out = **in
	}
	if in.StoreArtifactsLocally != nil {
		in, out := &in.StoreArtifactsLocally, &out.StoreArtifactsLocally
		*out = new(bool)
		**out = **in
	}
	if in.SynchronizeProperties != nil {
		in, out := &in.SynchronizeProperties, &out.SynchronizeProperties
		*out = new(bool)
		**out = **in
	}
	if in.URL != nil {
		in, out := &in.URL, &out.URL
		*out = new(string)
		**out = **in
	}
	if in.UnusedArtifactsCleanupPeriodHours != nil {
		in, out := &in.UnusedArtifactsCleanupPeriodHours, &out.UnusedArtifactsCleanupPeriodHours
		*out = new(float64)
		**out = **in
	}
	if in.Username != nil {
		in, out := &in.Username, &out.Username
		*out = new(string)
		**out = **in
	}
	if in.VcsGitDownloadURL != nil {
		in, out := &in.VcsGitDownloadURL, &out.VcsGitDownloadURL
		*out = new(string)
		**out = **in
	}
	if in.VcsGitProvider != nil {
		in, out := &in.VcsGitProvider, &out.VcsGitProvider
		*out = new(string)
		**out = **in
	}
	if in.XrayIndex != nil {
		in, out := &in.XrayIndex, &out.XrayIndex
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VcsRepositoryParameters.
func (in *VcsRepositoryParameters) DeepCopy() *VcsRepositoryParameters {
	if in == nil {
		return nil
	}
	out := new(VcsRepositoryParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VcsRepositorySpec) DeepCopyInto(out *VcsRepositorySpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VcsRepositorySpec.
func (in *VcsRepositorySpec) DeepCopy() *VcsRepositorySpec {
	if in == nil {
		return nil
	}
	out := new(VcsRepositorySpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *VcsRepositoryStatus) DeepCopyInto(out *VcsRepositoryStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new VcsRepositoryStatus.
func (in *VcsRepositoryStatus) DeepCopy() *VcsRepositoryStatus {
	if in == nil {
		return nil
	}
	out := new(VcsRepositoryStatus)
	in.DeepCopyInto(out)
	return out
}
